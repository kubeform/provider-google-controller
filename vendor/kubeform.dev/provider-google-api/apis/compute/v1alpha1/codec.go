/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1()):                                                     AutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                             AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):                    AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1()):                                                          BackendBucketSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1()):                                                         BackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                           BackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1()):                                                   BackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1()):                                                    BackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                          BackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                       BackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1()):                                                               BackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1()):                                                         BackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1()):                                                  BackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                                  BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1()):                                          BackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1()):                                                           DiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1()):                                                    DiskSpecSourceImageEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                                 DiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1()):                                                         DiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1()):                                                          DiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1()):                                                               FirewallSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicyRuleSpecMatch{}).Type1()):                                                         FirewallPolicyRuleSpecMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1()):                                                      HealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1()):                                                     HealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1()):                                                      HealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1()):                                                     HealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecLogConfig{}).Type1()):                                                            HealthCheckSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1()):                                                       HealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1()):                                                       HealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1()):                                                                    ImageSpecRawDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1()):                                                        ImageIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1()):                                                         ImageIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAdvancedMachineFeatures{}).Type1()):                                                 InstanceSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1()):                                                                InstanceSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1()):                                                InstanceSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1()):                                              InstanceSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinity{}).Type1()):                                                     InstanceSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinitySpecificReservation{}).Type1()):                                  InstanceSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1()):                                                              InstanceSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1()):                                                          InstanceSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1()):                                                  InstanceSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecAdvancedMachineFeatures{}).Type1()):                                     InstanceFromTemplateSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1()):                                                    InstanceFromTemplateSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1()):                                    InstanceFromTemplateSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1()):                                  InstanceFromTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinity{}).Type1()):                                         InstanceFromTemplateSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinitySpecificReservation{}).Type1()):                      InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1()):                                                  InstanceFromTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1()):                                              InstanceFromTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1()):                                      InstanceFromTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                         InstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                                InstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                           InstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1()):                                                     InstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1()):                                                      InstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecAdvancedMachineFeatures{}).Type1()):                                         InstanceTemplateSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1()):                                      InstanceTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1()):                                           InstanceTemplateSpecDiskDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinity{}).Type1()):                                             InstanceTemplateSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinitySpecificReservation{}).Type1()):                          InstanceTemplateSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1()):                                                      InstanceTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1()):                                                  InstanceTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1()):                                          InstanceTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagedSslCertificateSpecManaged{}).Type1()):                                                    ManagedSslCertificateSpecManagedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1()):                                                      NodeGroupSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1()):                                                      NodeGroupSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1()):                                                 NodeTemplateSpecNodeTypeFlexibilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1()):                                                       NodeTemplateSpecServerBindingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1()):                                                     PacketMirroringSpecCollectorIlbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1()):                                                           PacketMirroringSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1()):                                                PacketMirroringSpecMirroredResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1()):                                                          PacketMirroringSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1()):                                                 PerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1()):                                               RegionAutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                       RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):              RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1()):                                                   RegionBackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                     RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1()):                                             RegionBackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1()):                                              RegionBackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                    RegionBackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                 RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1()):                                              RegionBackendServiceSpecFailoverPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecIap{}).Type1()):                                                         RegionBackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1()):                                                   RegionBackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1()):                                            RegionBackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                            RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1()):                                    RegionBackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1()):                                                     RegionDiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                           RegionDiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1()):                                                   RegionDiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1()):                                                    RegionDiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1()):                                                RegionHealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1()):                                                RegionHealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecLogConfig{}).Type1()):                                                      RegionHealthCheckSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                   RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                          RegionInstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                     RegionInstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1()):                                             RegionNetworkEndpointGroupSpecAppEngineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1()):                                         RegionNetworkEndpointGroupSpecCloudFunctionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1()):                                              RegionNetworkEndpointGroupSpecCloudRunCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1()):                                           RegionPerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1()):                                                  RegionURLMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                       RegionURLMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                  RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                   RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                           RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):              RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                               RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                   RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):              RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                 RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                         RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):            RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                             RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1()):                                                  ReservationSpecSpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1()):                                ReservationSpecSpecificReservationInstancePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1()):                                              ResourcePolicySpecGroupPlacementPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicy{}).Type1()):                                            ResourcePolicySpecInstanceSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}).Type1()):                             ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}).Type1()):                              ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1()):                                            ResourcePolicySpecSnapshotSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1()):                             ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1()):                                    ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1()):                       ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1()):                          ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1()):                                                                       RouterSpecBgpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1()):                                                              RouterNATSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1()):                                                         SecurityPolicySpecRuleMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1()):                                                   SecurityPolicySpecRuleMatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1()):                                                     SecurityPolicySpecRuleMatchExprCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1()):                                                   SnapshotSpecSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1()):                                                 SnapshotSpecSourceDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1()):                                                             SubnetworkSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1()):                                                   SubnetworkIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1()):                                                    SubnetworkIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1()):                                                        UrlMapSpecDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1()):                                              UrlMapSpecDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1()):                                    UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):                     UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1()):                                     UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1()):                                             UrlMapSpecDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                                UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1()):                                                 UrlMapSpecDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1()):                                              UrlMapSpecDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):                     UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1()):                                                        UrlMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1()):                                                              UrlMapSpecHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1()):                                             UrlMapSpecPathMatcherDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1()):                         UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1()):                          UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1()):                                  UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                     UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1()):                                      UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                             UrlMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1()):                                                   UrlMapSpecPathMatcherHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                        UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                         UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                                 UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):                    UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                                     UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                         UrlMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):                    UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                      UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                       UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                               UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):                  UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                                   UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1()):                                                     AutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                             AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):                    AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1()):                                                          BackendBucketSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1()):                                                         BackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                           BackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1()):                                                   BackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1()):                                                    BackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                          BackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                       BackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1()):                                                               BackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1()):                                                         BackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1()):                                                  BackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                                  BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1()):                                          BackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1()):                                                           DiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1()):                                                    DiskSpecSourceImageEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                                 DiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1()):                                                         DiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1()):                                                          DiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1()):                                                               FirewallSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicyRuleSpecMatch{}).Type1()):                                                         FirewallPolicyRuleSpecMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1()):                                                      HealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1()):                                                     HealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1()):                                                      HealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1()):                                                     HealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecLogConfig{}).Type1()):                                                            HealthCheckSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1()):                                                       HealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1()):                                                       HealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1()):                                                                    ImageSpecRawDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1()):                                                        ImageIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1()):                                                         ImageIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAdvancedMachineFeatures{}).Type1()):                                                 InstanceSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1()):                                                                InstanceSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1()):                                                InstanceSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1()):                                              InstanceSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinity{}).Type1()):                                                     InstanceSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinitySpecificReservation{}).Type1()):                                  InstanceSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1()):                                                              InstanceSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1()):                                                          InstanceSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1()):                                                  InstanceSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecAdvancedMachineFeatures{}).Type1()):                                     InstanceFromTemplateSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1()):                                                    InstanceFromTemplateSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1()):                                    InstanceFromTemplateSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1()):                                  InstanceFromTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinity{}).Type1()):                                         InstanceFromTemplateSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinitySpecificReservation{}).Type1()):                      InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1()):                                                  InstanceFromTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1()):                                              InstanceFromTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1()):                                      InstanceFromTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                         InstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                                InstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                           InstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1()):                                                     InstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1()):                                                      InstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecAdvancedMachineFeatures{}).Type1()):                                         InstanceTemplateSpecAdvancedMachineFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1()):                                      InstanceTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1()):                                           InstanceTemplateSpecDiskDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinity{}).Type1()):                                             InstanceTemplateSpecReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinitySpecificReservation{}).Type1()):                          InstanceTemplateSpecReservationAffinitySpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1()):                                                      InstanceTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1()):                                                  InstanceTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1()):                                          InstanceTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagedSslCertificateSpecManaged{}).Type1()):                                                    ManagedSslCertificateSpecManagedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1()):                                                      NodeGroupSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1()):                                                      NodeGroupSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1()):                                                 NodeTemplateSpecNodeTypeFlexibilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1()):                                                       NodeTemplateSpecServerBindingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1()):                                                     PacketMirroringSpecCollectorIlbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1()):                                                           PacketMirroringSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1()):                                                PacketMirroringSpecMirroredResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1()):                                                          PacketMirroringSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1()):                                                 PerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1()):                                               RegionAutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                       RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):              RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1()):                                                   RegionBackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                     RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1()):                                             RegionBackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1()):                                              RegionBackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                    RegionBackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                 RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1()):                                              RegionBackendServiceSpecFailoverPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecIap{}).Type1()):                                                         RegionBackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1()):                                                   RegionBackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1()):                                            RegionBackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                            RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1()):                                    RegionBackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1()):                                                     RegionDiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                           RegionDiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1()):                                                   RegionDiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1()):                                                    RegionDiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1()):                                                RegionHealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1()):                                                RegionHealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecLogConfig{}).Type1()):                                                      RegionHealthCheckSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                   RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                          RegionInstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                     RegionInstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1()):                                             RegionNetworkEndpointGroupSpecAppEngineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1()):                                         RegionNetworkEndpointGroupSpecCloudFunctionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1()):                                              RegionNetworkEndpointGroupSpecCloudRunCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1()):                                           RegionPerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1()):                                                  RegionURLMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                       RegionURLMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                  RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                   RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                           RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):              RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                               RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                   RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):              RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                 RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                         RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):            RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                             RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1()):                                                  ReservationSpecSpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1()):                                ReservationSpecSpecificReservationInstancePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1()):                                              ResourcePolicySpecGroupPlacementPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicy{}).Type1()):                                            ResourcePolicySpecInstanceSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}).Type1()):                             ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}).Type1()):                              ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1()):                                            ResourcePolicySpecSnapshotSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1()):                             ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1()):                                    ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1()):                       ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1()):                          ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1()):                                                                       RouterSpecBgpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1()):                                                              RouterNATSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1()):                                                         SecurityPolicySpecRuleMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1()):                                                   SecurityPolicySpecRuleMatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1()):                                                     SecurityPolicySpecRuleMatchExprCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1()):                                                   SnapshotSpecSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1()):                                                 SnapshotSpecSourceDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1()):                                                             SubnetworkSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1()):                                                   SubnetworkIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1()):                                                    SubnetworkIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1()):                                                        UrlMapSpecDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1()):                                              UrlMapSpecDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1()):                                    UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):                     UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1()):                                     UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1()):                                             UrlMapSpecDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                                UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1()):                                                 UrlMapSpecDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1()):                                              UrlMapSpecDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):                     UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1()):                                                        UrlMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1()):                                                              UrlMapSpecHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1()):                                             UrlMapSpecPathMatcherDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1()):                         UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1()):                          UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1()):                                  UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                     UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1()):                                      UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                             UrlMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1()):                                                   UrlMapSpecPathMatcherHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                        UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                         UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                                 UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):                    UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                                     UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                         UrlMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):                    UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                      UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                       UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                               UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):                  UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                                   UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicy)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicy)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicy
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalerSpecAutoscalingPolicy)(ptr) = obj
		} else {
			*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyCpuUtilization
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyCpuUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = obj
		} else {
			*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyCpuUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = obj
		} else {
			*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyScaleInControlCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyScaleInControl
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyScaleInControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = obj
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyScaleInControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = obj
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendBucketSpecCdnPolicyCodec struct {
}

func (BackendBucketSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendBucketSpecCdnPolicy)(ptr) == nil
}

func (BackendBucketSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendBucketSpecCdnPolicy)(ptr)
	var objs []BackendBucketSpecCdnPolicy
	if obj != nil {
		objs = []BackendBucketSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendBucketSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendBucketSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendBucketSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
			}
		} else {
			*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendBucketSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendBucketSpecCdnPolicy)(ptr) = obj
		} else {
			*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode BackendBucketSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCdnPolicyCodec struct {
}

func (BackendServiceSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCdnPolicy)(ptr) == nil
}

func (BackendServiceSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCdnPolicy)(ptr)
	var objs []BackendServiceSpecCdnPolicy
	if obj != nil {
		objs = []BackendServiceSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
			}
		} else {
			*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecCdnPolicy)(ptr) = obj
		} else {
			*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCdnPolicyCacheKeyPolicyCodec struct {
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) == nil
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr)
	var objs []BackendServiceSpecCdnPolicyCacheKeyPolicy
	if obj != nil {
		objs = []BackendServiceSpecCdnPolicyCacheKeyPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
			}
		} else {
			*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = obj
		} else {
			*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCdnPolicyCacheKeyPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCircuitBreakersCodec struct {
}

func (BackendServiceSpecCircuitBreakersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCircuitBreakers)(ptr) == nil
}

func (BackendServiceSpecCircuitBreakersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCircuitBreakers)(ptr)
	var objs []BackendServiceSpecCircuitBreakers
	if obj != nil {
		objs = []BackendServiceSpecCircuitBreakers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCircuitBreakersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCircuitBreakers)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
			}
		} else {
			*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecCircuitBreakers)(ptr) = obj
		} else {
			*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCircuitBreakers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashCodec struct {
}

func (BackendServiceSpecConsistentHashCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHash)(ptr) == nil
}

func (BackendServiceSpecConsistentHashCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHash)(ptr)
	var objs []BackendServiceSpecConsistentHash
	if obj != nil {
		objs = []BackendServiceSpecConsistentHash{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHash)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
			}
		} else {
			*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecConsistentHash)(ptr) = obj
		} else {
			*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHash", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashHttpCookieCodec struct {
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHashHttpCookie)(ptr) == nil
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHashHttpCookie)(ptr)
	var objs []BackendServiceSpecConsistentHashHttpCookie
	if obj != nil {
		objs = []BackendServiceSpecConsistentHashHttpCookie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
			}
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = obj
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHashHttpCookie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashHttpCookieTtlCodec struct {
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) == nil
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr)
	var objs []BackendServiceSpecConsistentHashHttpCookieTtl
	if obj != nil {
		objs = []BackendServiceSpecConsistentHashHttpCookieTtl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
			}
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = obj
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHashHttpCookieTtl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecIapCodec struct {
}

func (BackendServiceSpecIapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecIap)(ptr) == nil
}

func (BackendServiceSpecIapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecIap)(ptr)
	var objs []BackendServiceSpecIap
	if obj != nil {
		objs = []BackendServiceSpecIap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecIapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecIap)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
			}
		} else {
			*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecIap)(ptr) = obj
		} else {
			*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecIap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecLogConfigCodec struct {
}

func (BackendServiceSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecLogConfig)(ptr) == nil
}

func (BackendServiceSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecLogConfig)(ptr)
	var objs []BackendServiceSpecLogConfig
	if obj != nil {
		objs = []BackendServiceSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
			}
		} else {
			*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecLogConfig)(ptr) = obj
		} else {
			*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionCodec struct {
}

func (BackendServiceSpecOutlierDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetection)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetection)(ptr)
	var objs []BackendServiceSpecOutlierDetection
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetection)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecOutlierDetection)(ptr) = obj
		} else {
			*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec struct {
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr)
	var objs []BackendServiceSpecOutlierDetectionBaseEjectionTime
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetectionBaseEjectionTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = obj
		} else {
			*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetectionBaseEjectionTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionIntervalCodec struct {
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetectionInterval)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetectionInterval)(ptr)
	var objs []BackendServiceSpecOutlierDetectionInterval
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetectionInterval{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = obj
		} else {
			*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetectionInterval", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecDiskEncryptionKeyCodec struct {
}

func (DiskSpecDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecDiskEncryptionKey)(ptr) == nil
}

func (DiskSpecDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecDiskEncryptionKey)(ptr)
	var objs []DiskSpecDiskEncryptionKey
	if obj != nil {
		objs = []DiskSpecDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
			}
		} else {
			*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiskSpecDiskEncryptionKey)(ptr) = obj
		} else {
			*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecSourceImageEncryptionKeyCodec struct {
}

func (DiskSpecSourceImageEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecSourceImageEncryptionKey)(ptr) == nil
}

func (DiskSpecSourceImageEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecSourceImageEncryptionKey)(ptr)
	var objs []DiskSpecSourceImageEncryptionKey
	if obj != nil {
		objs = []DiskSpecSourceImageEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecSourceImageEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecSourceImageEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecSourceImageEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
			}
		} else {
			*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiskSpecSourceImageEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiskSpecSourceImageEncryptionKey)(ptr) = obj
		} else {
			*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecSourceImageEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecSourceSnapshotEncryptionKeyCodec struct {
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecSourceSnapshotEncryptionKey)(ptr) == nil
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecSourceSnapshotEncryptionKey)(ptr)
	var objs []DiskSpecSourceSnapshotEncryptionKey
	if obj != nil {
		objs = []DiskSpecSourceSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
			}
		} else {
			*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = obj
		} else {
			*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecSourceSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskIamBindingSpecConditionCodec struct {
}

func (DiskIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskIamBindingSpecCondition)(ptr) == nil
}

func (DiskIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskIamBindingSpecCondition)(ptr)
	var objs []DiskIamBindingSpecCondition
	if obj != nil {
		objs = []DiskIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
			}
		} else {
			*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiskIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode DiskIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskIamMemberSpecConditionCodec struct {
}

func (DiskIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskIamMemberSpecCondition)(ptr) == nil
}

func (DiskIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskIamMemberSpecCondition)(ptr)
	var objs []DiskIamMemberSpecCondition
	if obj != nil {
		objs = []DiskIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
			}
		} else {
			*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiskIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode DiskIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecLogConfigCodec struct {
}

func (FirewallSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecLogConfig)(ptr) == nil
}

func (FirewallSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecLogConfig)(ptr)
	var objs []FirewallSpecLogConfig
	if obj != nil {
		objs = []FirewallSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
			}
		} else {
			*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecLogConfig)(ptr) = obj
		} else {
			*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
		}
	default:
		iter.ReportError("decode FirewallSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallPolicyRuleSpecMatchCodec struct {
}

func (FirewallPolicyRuleSpecMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallPolicyRuleSpecMatch)(ptr) == nil
}

func (FirewallPolicyRuleSpecMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallPolicyRuleSpecMatch)(ptr)
	var objs []FirewallPolicyRuleSpecMatch
	if obj != nil {
		objs = []FirewallPolicyRuleSpecMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicyRuleSpecMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallPolicyRuleSpecMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallPolicyRuleSpecMatch)(ptr) = FirewallPolicyRuleSpecMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallPolicyRuleSpecMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicyRuleSpecMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallPolicyRuleSpecMatch)(ptr) = objs[0]
			} else {
				*(*FirewallPolicyRuleSpecMatch)(ptr) = FirewallPolicyRuleSpecMatch{}
			}
		} else {
			*(*FirewallPolicyRuleSpecMatch)(ptr) = FirewallPolicyRuleSpecMatch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallPolicyRuleSpecMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicyRuleSpecMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallPolicyRuleSpecMatch)(ptr) = obj
		} else {
			*(*FirewallPolicyRuleSpecMatch)(ptr) = FirewallPolicyRuleSpecMatch{}
		}
	default:
		iter.ReportError("decode FirewallPolicyRuleSpecMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecGrpcHealthCheckCodec struct {
}

func (HealthCheckSpecGrpcHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecGrpcHealthCheck)(ptr) == nil
}

func (HealthCheckSpecGrpcHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecGrpcHealthCheck)(ptr)
	var objs []HealthCheckSpecGrpcHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecGrpcHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecGrpcHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecGrpcHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecGrpcHealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecGrpcHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttp2HealthCheckCodec struct {
}

func (HealthCheckSpecHttp2HealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttp2HealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttp2HealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttp2HealthCheck)(ptr)
	var objs []HealthCheckSpecHttp2HealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttp2HealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttp2HealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttp2HealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecHttp2HealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttp2HealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttpHealthCheckCodec struct {
}

func (HealthCheckSpecHttpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttpHealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttpHealthCheck)(ptr)
	var objs []HealthCheckSpecHttpHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttpHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecHttpHealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttpsHealthCheckCodec struct {
}

func (HealthCheckSpecHttpsHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttpsHealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttpsHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttpsHealthCheck)(ptr)
	var objs []HealthCheckSpecHttpsHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttpsHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttpsHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttpsHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecHttpsHealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttpsHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecLogConfigCodec struct {
}

func (HealthCheckSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecLogConfig)(ptr) == nil
}

func (HealthCheckSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecLogConfig)(ptr)
	var objs []HealthCheckSpecLogConfig
	if obj != nil {
		objs = []HealthCheckSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecLogConfig)(ptr) = HealthCheckSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecLogConfig)(ptr) = HealthCheckSpecLogConfig{}
			}
		} else {
			*(*HealthCheckSpecLogConfig)(ptr) = HealthCheckSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecLogConfig)(ptr) = obj
		} else {
			*(*HealthCheckSpecLogConfig)(ptr) = HealthCheckSpecLogConfig{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecSslHealthCheckCodec struct {
}

func (HealthCheckSpecSslHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecSslHealthCheck)(ptr) == nil
}

func (HealthCheckSpecSslHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecSslHealthCheck)(ptr)
	var objs []HealthCheckSpecSslHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecSslHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecSslHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecSslHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecSslHealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecSslHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecTcpHealthCheckCodec struct {
}

func (HealthCheckSpecTcpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecTcpHealthCheck)(ptr) == nil
}

func (HealthCheckSpecTcpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecTcpHealthCheck)(ptr)
	var objs []HealthCheckSpecTcpHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecTcpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecTcpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecTcpHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HealthCheckSpecTcpHealthCheck)(ptr) = obj
		} else {
			*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecTcpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageSpecRawDiskCodec struct {
}

func (ImageSpecRawDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageSpecRawDisk)(ptr) == nil
}

func (ImageSpecRawDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageSpecRawDisk)(ptr)
	var objs []ImageSpecRawDisk
	if obj != nil {
		objs = []ImageSpecRawDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageSpecRawDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageSpecRawDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageSpecRawDisk)(ptr) = objs[0]
			} else {
				*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
			}
		} else {
			*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageSpecRawDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageSpecRawDisk)(ptr) = obj
		} else {
			*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
		}
	default:
		iter.ReportError("decode ImageSpecRawDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageIamBindingSpecConditionCodec struct {
}

func (ImageIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageIamBindingSpecCondition)(ptr) == nil
}

func (ImageIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageIamBindingSpecCondition)(ptr)
	var objs []ImageIamBindingSpecCondition
	if obj != nil {
		objs = []ImageIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
			}
		} else {
			*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode ImageIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageIamMemberSpecConditionCodec struct {
}

func (ImageIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageIamMemberSpecCondition)(ptr) == nil
}

func (ImageIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageIamMemberSpecCondition)(ptr)
	var objs []ImageIamMemberSpecCondition
	if obj != nil {
		objs = []ImageIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
			}
		} else {
			*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode ImageIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecAdvancedMachineFeaturesCodec struct {
}

func (InstanceSpecAdvancedMachineFeaturesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecAdvancedMachineFeatures)(ptr) == nil
}

func (InstanceSpecAdvancedMachineFeaturesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecAdvancedMachineFeatures)(ptr)
	var objs []InstanceSpecAdvancedMachineFeatures
	if obj != nil {
		objs = []InstanceSpecAdvancedMachineFeatures{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAdvancedMachineFeatures{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecAdvancedMachineFeaturesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecAdvancedMachineFeatures)(ptr) = InstanceSpecAdvancedMachineFeatures{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecAdvancedMachineFeatures)(ptr) = objs[0]
			} else {
				*(*InstanceSpecAdvancedMachineFeatures)(ptr) = InstanceSpecAdvancedMachineFeatures{}
			}
		} else {
			*(*InstanceSpecAdvancedMachineFeatures)(ptr) = InstanceSpecAdvancedMachineFeatures{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecAdvancedMachineFeatures)(ptr) = obj
		} else {
			*(*InstanceSpecAdvancedMachineFeatures)(ptr) = InstanceSpecAdvancedMachineFeatures{}
		}
	default:
		iter.ReportError("decode InstanceSpecAdvancedMachineFeatures", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecBootDiskCodec struct {
}

func (InstanceSpecBootDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecBootDisk)(ptr) == nil
}

func (InstanceSpecBootDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecBootDisk)(ptr)
	var objs []InstanceSpecBootDisk
	if obj != nil {
		objs = []InstanceSpecBootDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecBootDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecBootDisk)(ptr) = objs[0]
			} else {
				*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
			}
		} else {
			*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecBootDisk)(ptr) = obj
		} else {
			*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
		}
	default:
		iter.ReportError("decode InstanceSpecBootDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecBootDiskInitializeParamsCodec struct {
}

func (InstanceSpecBootDiskInitializeParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecBootDiskInitializeParams)(ptr) == nil
}

func (InstanceSpecBootDiskInitializeParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecBootDiskInitializeParams)(ptr)
	var objs []InstanceSpecBootDiskInitializeParams
	if obj != nil {
		objs = []InstanceSpecBootDiskInitializeParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecBootDiskInitializeParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecBootDiskInitializeParams)(ptr) = objs[0]
			} else {
				*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
			}
		} else {
			*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecBootDiskInitializeParams)(ptr) = obj
		} else {
			*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
		}
	default:
		iter.ReportError("decode InstanceSpecBootDiskInitializeParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfidentialInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecReservationAffinityCodec struct {
}

func (InstanceSpecReservationAffinityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecReservationAffinity)(ptr) == nil
}

func (InstanceSpecReservationAffinityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecReservationAffinity)(ptr)
	var objs []InstanceSpecReservationAffinity
	if obj != nil {
		objs = []InstanceSpecReservationAffinity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecReservationAffinityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecReservationAffinity)(ptr) = InstanceSpecReservationAffinity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecReservationAffinity)(ptr) = objs[0]
			} else {
				*(*InstanceSpecReservationAffinity)(ptr) = InstanceSpecReservationAffinity{}
			}
		} else {
			*(*InstanceSpecReservationAffinity)(ptr) = InstanceSpecReservationAffinity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecReservationAffinity)(ptr) = obj
		} else {
			*(*InstanceSpecReservationAffinity)(ptr) = InstanceSpecReservationAffinity{}
		}
	default:
		iter.ReportError("decode InstanceSpecReservationAffinity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecReservationAffinitySpecificReservationCodec struct {
}

func (InstanceSpecReservationAffinitySpecificReservationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecReservationAffinitySpecificReservation)(ptr) == nil
}

func (InstanceSpecReservationAffinitySpecificReservationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecReservationAffinitySpecificReservation)(ptr)
	var objs []InstanceSpecReservationAffinitySpecificReservation
	if obj != nil {
		objs = []InstanceSpecReservationAffinitySpecificReservation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinitySpecificReservation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecReservationAffinitySpecificReservationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = InstanceSpecReservationAffinitySpecificReservation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = objs[0]
			} else {
				*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = InstanceSpecReservationAffinitySpecificReservation{}
			}
		} else {
			*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = InstanceSpecReservationAffinitySpecificReservation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = obj
		} else {
			*(*InstanceSpecReservationAffinitySpecificReservation)(ptr) = InstanceSpecReservationAffinitySpecificReservation{}
		}
	default:
		iter.ReportError("decode InstanceSpecReservationAffinitySpecificReservation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecSchedulingCodec struct {
}

func (InstanceSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecScheduling)(ptr) == nil
}

func (InstanceSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecScheduling)(ptr)
	var objs []InstanceSpecScheduling
	if obj != nil {
		objs = []InstanceSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
			}
		} else {
			*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecScheduling)(ptr) = obj
		} else {
			*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecServiceAccountCodec struct {
}

func (InstanceSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecServiceAccount)(ptr) == nil
}

func (InstanceSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecServiceAccount)(ptr)
	var objs []InstanceSpecServiceAccount
	if obj != nil {
		objs = []InstanceSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
			}
		} else {
			*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecServiceAccount)(ptr) = obj
		} else {
			*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecShieldedInstanceConfigCodec struct {
}

func (InstanceSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecAdvancedMachineFeaturesCodec struct {
}

func (InstanceFromTemplateSpecAdvancedMachineFeaturesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) == nil
}

func (InstanceFromTemplateSpecAdvancedMachineFeaturesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr)
	var objs []InstanceFromTemplateSpecAdvancedMachineFeatures
	if obj != nil {
		objs = []InstanceFromTemplateSpecAdvancedMachineFeatures{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecAdvancedMachineFeatures{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecAdvancedMachineFeaturesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceFromTemplateSpecAdvancedMachineFeatures{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceFromTemplateSpecAdvancedMachineFeatures{}
			}
		} else {
			*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceFromTemplateSpecAdvancedMachineFeatures{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceFromTemplateSpecAdvancedMachineFeatures{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecAdvancedMachineFeatures", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecBootDiskCodec struct {
}

func (InstanceFromTemplateSpecBootDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecBootDisk)(ptr) == nil
}

func (InstanceFromTemplateSpecBootDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecBootDisk)(ptr)
	var objs []InstanceFromTemplateSpecBootDisk
	if obj != nil {
		objs = []InstanceFromTemplateSpecBootDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecBootDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecBootDisk)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
			}
		} else {
			*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecBootDisk)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecBootDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecBootDiskInitializeParamsCodec struct {
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) == nil
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr)
	var objs []InstanceFromTemplateSpecBootDiskInitializeParams
	if obj != nil {
		objs = []InstanceFromTemplateSpecBootDiskInitializeParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
			}
		} else {
			*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecBootDiskInitializeParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceFromTemplateSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceFromTemplateSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecReservationAffinityCodec struct {
}

func (InstanceFromTemplateSpecReservationAffinityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecReservationAffinity)(ptr) == nil
}

func (InstanceFromTemplateSpecReservationAffinityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecReservationAffinity)(ptr)
	var objs []InstanceFromTemplateSpecReservationAffinity
	if obj != nil {
		objs = []InstanceFromTemplateSpecReservationAffinity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecReservationAffinityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = InstanceFromTemplateSpecReservationAffinity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = InstanceFromTemplateSpecReservationAffinity{}
			}
		} else {
			*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = InstanceFromTemplateSpecReservationAffinity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecReservationAffinity)(ptr) = InstanceFromTemplateSpecReservationAffinity{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecReservationAffinity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec struct {
}

func (InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) == nil
}

func (InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr)
	var objs []InstanceFromTemplateSpecReservationAffinitySpecificReservation
	if obj != nil {
		objs = []InstanceFromTemplateSpecReservationAffinitySpecificReservation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecReservationAffinitySpecificReservationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceFromTemplateSpecReservationAffinitySpecificReservation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceFromTemplateSpecReservationAffinitySpecificReservation{}
			}
		} else {
			*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceFromTemplateSpecReservationAffinitySpecificReservation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceFromTemplateSpecReservationAffinitySpecificReservation{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecReservationAffinitySpecificReservation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecSchedulingCodec struct {
}

func (InstanceFromTemplateSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecScheduling)(ptr) == nil
}

func (InstanceFromTemplateSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecScheduling)(ptr)
	var objs []InstanceFromTemplateSpecScheduling
	if obj != nil {
		objs = []InstanceFromTemplateSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
			}
		} else {
			*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecScheduling)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecServiceAccountCodec struct {
}

func (InstanceFromTemplateSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecServiceAccount)(ptr) == nil
}

func (InstanceFromTemplateSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecServiceAccount)(ptr)
	var objs []InstanceFromTemplateSpecServiceAccount
	if obj != nil {
		objs = []InstanceFromTemplateSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
			}
		} else {
			*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecServiceAccount)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecShieldedInstanceConfigCodec struct {
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceFromTemplateSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceFromTemplateSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceFromTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecAutoHealingPoliciesCodec struct {
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) == nil
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecAutoHealingPolicies)(ptr)
	var objs []InstanceGroupManagerSpecAutoHealingPolicies
	if obj != nil {
		objs = []InstanceGroupManagerSpecAutoHealingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
			}
		} else {
			*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = obj
		} else {
			*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecAutoHealingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecUpdatePolicyCodec struct {
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecUpdatePolicy)(ptr) == nil
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecUpdatePolicy)(ptr)
	var objs []InstanceGroupManagerSpecUpdatePolicy
	if obj != nil {
		objs = []InstanceGroupManagerSpecUpdatePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
			}
		} else {
			*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = obj
		} else {
			*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecUpdatePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecVersionTargetSizeCodec struct {
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecVersionTargetSize)(ptr) == nil
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecVersionTargetSize)(ptr)
	var objs []InstanceGroupManagerSpecVersionTargetSize
	if obj != nil {
		objs = []InstanceGroupManagerSpecVersionTargetSize{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
			}
		} else {
			*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = obj
		} else {
			*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecVersionTargetSize", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceIamBindingSpecConditionCodec struct {
}

func (InstanceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceIamBindingSpecCondition)(ptr) == nil
}

func (InstanceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceIamBindingSpecCondition)(ptr)
	var objs []InstanceIamBindingSpecCondition
	if obj != nil {
		objs = []InstanceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
			}
		} else {
			*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode InstanceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceIamMemberSpecConditionCodec struct {
}

func (InstanceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceIamMemberSpecCondition)(ptr) == nil
}

func (InstanceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceIamMemberSpecCondition)(ptr)
	var objs []InstanceIamMemberSpecCondition
	if obj != nil {
		objs = []InstanceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
			}
		} else {
			*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode InstanceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecAdvancedMachineFeaturesCodec struct {
}

func (InstanceTemplateSpecAdvancedMachineFeaturesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) == nil
}

func (InstanceTemplateSpecAdvancedMachineFeaturesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecAdvancedMachineFeatures)(ptr)
	var objs []InstanceTemplateSpecAdvancedMachineFeatures
	if obj != nil {
		objs = []InstanceTemplateSpecAdvancedMachineFeatures{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecAdvancedMachineFeatures{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecAdvancedMachineFeaturesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceTemplateSpecAdvancedMachineFeatures{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceTemplateSpecAdvancedMachineFeatures{}
			}
		} else {
			*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceTemplateSpecAdvancedMachineFeatures{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecAdvancedMachineFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecAdvancedMachineFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecAdvancedMachineFeatures)(ptr) = InstanceTemplateSpecAdvancedMachineFeatures{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecAdvancedMachineFeatures", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceTemplateSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceTemplateSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecDiskDiskEncryptionKeyCodec struct {
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) == nil
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr)
	var objs []InstanceTemplateSpecDiskDiskEncryptionKey
	if obj != nil {
		objs = []InstanceTemplateSpecDiskDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecDiskDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
			}
		} else {
			*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecDiskDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecDiskDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecReservationAffinityCodec struct {
}

func (InstanceTemplateSpecReservationAffinityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecReservationAffinity)(ptr) == nil
}

func (InstanceTemplateSpecReservationAffinityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecReservationAffinity)(ptr)
	var objs []InstanceTemplateSpecReservationAffinity
	if obj != nil {
		objs = []InstanceTemplateSpecReservationAffinity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecReservationAffinityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecReservationAffinity)(ptr) = InstanceTemplateSpecReservationAffinity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecReservationAffinity)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecReservationAffinity)(ptr) = InstanceTemplateSpecReservationAffinity{}
			}
		} else {
			*(*InstanceTemplateSpecReservationAffinity)(ptr) = InstanceTemplateSpecReservationAffinity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecReservationAffinity)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecReservationAffinity)(ptr) = InstanceTemplateSpecReservationAffinity{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecReservationAffinity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecReservationAffinitySpecificReservationCodec struct {
}

func (InstanceTemplateSpecReservationAffinitySpecificReservationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) == nil
}

func (InstanceTemplateSpecReservationAffinitySpecificReservationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr)
	var objs []InstanceTemplateSpecReservationAffinitySpecificReservation
	if obj != nil {
		objs = []InstanceTemplateSpecReservationAffinitySpecificReservation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecReservationAffinitySpecificReservationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceTemplateSpecReservationAffinitySpecificReservation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceTemplateSpecReservationAffinitySpecificReservation{}
			}
		} else {
			*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceTemplateSpecReservationAffinitySpecificReservation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecReservationAffinitySpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecReservationAffinitySpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecReservationAffinitySpecificReservation)(ptr) = InstanceTemplateSpecReservationAffinitySpecificReservation{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecReservationAffinitySpecificReservation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecSchedulingCodec struct {
}

func (InstanceTemplateSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecScheduling)(ptr) == nil
}

func (InstanceTemplateSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecScheduling)(ptr)
	var objs []InstanceTemplateSpecScheduling
	if obj != nil {
		objs = []InstanceTemplateSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
			}
		} else {
			*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecScheduling)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecServiceAccountCodec struct {
}

func (InstanceTemplateSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecServiceAccount)(ptr) == nil
}

func (InstanceTemplateSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecServiceAccount)(ptr)
	var objs []InstanceTemplateSpecServiceAccount
	if obj != nil {
		objs = []InstanceTemplateSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
			}
		} else {
			*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecServiceAccount)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecShieldedInstanceConfigCodec struct {
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceTemplateSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceTemplateSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagedSslCertificateSpecManagedCodec struct {
}

func (ManagedSslCertificateSpecManagedCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagedSslCertificateSpecManaged)(ptr) == nil
}

func (ManagedSslCertificateSpecManagedCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagedSslCertificateSpecManaged)(ptr)
	var objs []ManagedSslCertificateSpecManaged
	if obj != nil {
		objs = []ManagedSslCertificateSpecManaged{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagedSslCertificateSpecManaged{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagedSslCertificateSpecManagedCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagedSslCertificateSpecManaged)(ptr) = ManagedSslCertificateSpecManaged{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagedSslCertificateSpecManaged

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagedSslCertificateSpecManaged{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagedSslCertificateSpecManaged)(ptr) = objs[0]
			} else {
				*(*ManagedSslCertificateSpecManaged)(ptr) = ManagedSslCertificateSpecManaged{}
			}
		} else {
			*(*ManagedSslCertificateSpecManaged)(ptr) = ManagedSslCertificateSpecManaged{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagedSslCertificateSpecManaged

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagedSslCertificateSpecManaged{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagedSslCertificateSpecManaged)(ptr) = obj
		} else {
			*(*ManagedSslCertificateSpecManaged)(ptr) = ManagedSslCertificateSpecManaged{}
		}
	default:
		iter.ReportError("decode ManagedSslCertificateSpecManaged", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeGroupSpecAutoscalingPolicyCodec struct {
}

func (NodeGroupSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeGroupSpecAutoscalingPolicy)(ptr) == nil
}

func (NodeGroupSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeGroupSpecAutoscalingPolicy)(ptr)
	var objs []NodeGroupSpecAutoscalingPolicy
	if obj != nil {
		objs = []NodeGroupSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeGroupSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeGroupSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeGroupSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
			}
		} else {
			*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodeGroupSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodeGroupSpecAutoscalingPolicy)(ptr) = obj
		} else {
			*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode NodeGroupSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeGroupSpecMaintenanceWindowCodec struct {
}

func (NodeGroupSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeGroupSpecMaintenanceWindow)(ptr) == nil
}

func (NodeGroupSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeGroupSpecMaintenanceWindow)(ptr)
	var objs []NodeGroupSpecMaintenanceWindow
	if obj != nil {
		objs = []NodeGroupSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeGroupSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeGroupSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeGroupSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
			}
		} else {
			*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodeGroupSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodeGroupSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode NodeGroupSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeTemplateSpecNodeTypeFlexibilityCodec struct {
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeTemplateSpecNodeTypeFlexibility)(ptr) == nil
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeTemplateSpecNodeTypeFlexibility)(ptr)
	var objs []NodeTemplateSpecNodeTypeFlexibility
	if obj != nil {
		objs = []NodeTemplateSpecNodeTypeFlexibility{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeTemplateSpecNodeTypeFlexibility

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = objs[0]
			} else {
				*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
			}
		} else {
			*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodeTemplateSpecNodeTypeFlexibility

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = obj
		} else {
			*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
		}
	default:
		iter.ReportError("decode NodeTemplateSpecNodeTypeFlexibility", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeTemplateSpecServerBindingCodec struct {
}

func (NodeTemplateSpecServerBindingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeTemplateSpecServerBinding)(ptr) == nil
}

func (NodeTemplateSpecServerBindingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeTemplateSpecServerBinding)(ptr)
	var objs []NodeTemplateSpecServerBinding
	if obj != nil {
		objs = []NodeTemplateSpecServerBinding{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeTemplateSpecServerBindingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeTemplateSpecServerBinding

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeTemplateSpecServerBinding)(ptr) = objs[0]
			} else {
				*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
			}
		} else {
			*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodeTemplateSpecServerBinding

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodeTemplateSpecServerBinding)(ptr) = obj
		} else {
			*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
		}
	default:
		iter.ReportError("decode NodeTemplateSpecServerBinding", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecCollectorIlbCodec struct {
}

func (PacketMirroringSpecCollectorIlbCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecCollectorIlb)(ptr) == nil
}

func (PacketMirroringSpecCollectorIlbCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecCollectorIlb)(ptr)
	var objs []PacketMirroringSpecCollectorIlb
	if obj != nil {
		objs = []PacketMirroringSpecCollectorIlb{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecCollectorIlbCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecCollectorIlb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecCollectorIlb)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
			}
		} else {
			*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PacketMirroringSpecCollectorIlb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PacketMirroringSpecCollectorIlb)(ptr) = obj
		} else {
			*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecCollectorIlb", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecFilterCodec struct {
}

func (PacketMirroringSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecFilter)(ptr) == nil
}

func (PacketMirroringSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecFilter)(ptr)
	var objs []PacketMirroringSpecFilter
	if obj != nil {
		objs = []PacketMirroringSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecFilter)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
			}
		} else {
			*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PacketMirroringSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PacketMirroringSpecFilter)(ptr) = obj
		} else {
			*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecMirroredResourcesCodec struct {
}

func (PacketMirroringSpecMirroredResourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecMirroredResources)(ptr) == nil
}

func (PacketMirroringSpecMirroredResourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecMirroredResources)(ptr)
	var objs []PacketMirroringSpecMirroredResources
	if obj != nil {
		objs = []PacketMirroringSpecMirroredResources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecMirroredResourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecMirroredResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecMirroredResources)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
			}
		} else {
			*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PacketMirroringSpecMirroredResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PacketMirroringSpecMirroredResources)(ptr) = obj
		} else {
			*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecMirroredResources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecNetworkCodec struct {
}

func (PacketMirroringSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecNetwork)(ptr) == nil
}

func (PacketMirroringSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecNetwork)(ptr)
	var objs []PacketMirroringSpecNetwork
	if obj != nil {
		objs = []PacketMirroringSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecNetwork)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
			}
		} else {
			*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PacketMirroringSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PacketMirroringSpecNetwork)(ptr) = obj
		} else {
			*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PerInstanceConfigSpecPreservedStateCodec struct {
}

func (PerInstanceConfigSpecPreservedStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PerInstanceConfigSpecPreservedState)(ptr) == nil
}

func (PerInstanceConfigSpecPreservedStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PerInstanceConfigSpecPreservedState)(ptr)
	var objs []PerInstanceConfigSpecPreservedState
	if obj != nil {
		objs = []PerInstanceConfigSpecPreservedState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PerInstanceConfigSpecPreservedStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PerInstanceConfigSpecPreservedState)(ptr) = objs[0]
			} else {
				*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
			}
		} else {
			*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PerInstanceConfigSpecPreservedState)(ptr) = obj
		} else {
			*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
		}
	default:
		iter.ReportError("decode PerInstanceConfigSpecPreservedState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicy)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicy)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicy
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionAutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = obj
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionAutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = obj
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyCpuUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = obj
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControl
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyScaleInControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionAutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = obj
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyScaleInControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = obj
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCdnPolicyCodec struct {
}

func (RegionBackendServiceSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCdnPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCdnPolicy)(ptr)
	var objs []RegionBackendServiceSpecCdnPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecCdnPolicy)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec struct {
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr)
	var objs []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCdnPolicyCacheKeyPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCircuitBreakersCodec struct {
}

func (RegionBackendServiceSpecCircuitBreakersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCircuitBreakers)(ptr) == nil
}

func (RegionBackendServiceSpecCircuitBreakersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCircuitBreakers)(ptr)
	var objs []RegionBackendServiceSpecCircuitBreakers
	if obj != nil {
		objs = []RegionBackendServiceSpecCircuitBreakers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCircuitBreakersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
			}
		} else {
			*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCircuitBreakers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashCodec struct {
}

func (RegionBackendServiceSpecConsistentHashCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHash)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHash)(ptr)
	var objs []RegionBackendServiceSpecConsistentHash
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHash{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHash)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecConsistentHash)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHash", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashHttpCookieCodec struct {
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr)
	var objs []RegionBackendServiceSpecConsistentHashHttpCookie
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHashHttpCookie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHashHttpCookie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec struct {
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr)
	var objs []RegionBackendServiceSpecConsistentHashHttpCookieTtl
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHashHttpCookieTtl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHashHttpCookieTtl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecFailoverPolicyCodec struct {
}

func (RegionBackendServiceSpecFailoverPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecFailoverPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecFailoverPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecFailoverPolicy)(ptr)
	var objs []RegionBackendServiceSpecFailoverPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecFailoverPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecFailoverPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecFailoverPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecFailoverPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecFailoverPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecIapCodec struct {
}

func (RegionBackendServiceSpecIapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecIap)(ptr) == nil
}

func (RegionBackendServiceSpecIapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecIap)(ptr)
	var objs []RegionBackendServiceSpecIap
	if obj != nil {
		objs = []RegionBackendServiceSpecIap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecIap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecIapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecIap)(ptr) = RegionBackendServiceSpecIap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecIap)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecIap)(ptr) = RegionBackendServiceSpecIap{}
			}
		} else {
			*(*RegionBackendServiceSpecIap)(ptr) = RegionBackendServiceSpecIap{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecIap)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecIap)(ptr) = RegionBackendServiceSpecIap{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecIap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecLogConfigCodec struct {
}

func (RegionBackendServiceSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecLogConfig)(ptr) == nil
}

func (RegionBackendServiceSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecLogConfig)(ptr)
	var objs []RegionBackendServiceSpecLogConfig
	if obj != nil {
		objs = []RegionBackendServiceSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
			}
		} else {
			*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecLogConfig)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetection)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetection)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetection
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetection)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecOutlierDetection)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetectionBaseEjectionTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionIntervalCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetectionInterval)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetectionInterval
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetectionInterval{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionBackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = obj
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetectionInterval", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskSpecDiskEncryptionKeyCodec struct {
}

func (RegionDiskSpecDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskSpecDiskEncryptionKey)(ptr) == nil
}

func (RegionDiskSpecDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskSpecDiskEncryptionKey)(ptr)
	var objs []RegionDiskSpecDiskEncryptionKey
	if obj != nil {
		objs = []RegionDiskSpecDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskSpecDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskSpecDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
			}
		} else {
			*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionDiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionDiskSpecDiskEncryptionKey)(ptr) = obj
		} else {
			*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode RegionDiskSpecDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskSpecSourceSnapshotEncryptionKeyCodec struct {
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) == nil
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr)
	var objs []RegionDiskSpecSourceSnapshotEncryptionKey
	if obj != nil {
		objs = []RegionDiskSpecSourceSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
			}
		} else {
			*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionDiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = obj
		} else {
			*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode RegionDiskSpecSourceSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskIamBindingSpecConditionCodec struct {
}

func (RegionDiskIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskIamBindingSpecCondition)(ptr) == nil
}

func (RegionDiskIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskIamBindingSpecCondition)(ptr)
	var objs []RegionDiskIamBindingSpecCondition
	if obj != nil {
		objs = []RegionDiskIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
			}
		} else {
			*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionDiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionDiskIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode RegionDiskIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskIamMemberSpecConditionCodec struct {
}

func (RegionDiskIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskIamMemberSpecCondition)(ptr) == nil
}

func (RegionDiskIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskIamMemberSpecCondition)(ptr)
	var objs []RegionDiskIamMemberSpecCondition
	if obj != nil {
		objs = []RegionDiskIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
			}
		} else {
			*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionDiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionDiskIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode RegionDiskIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecGrpcHealthCheckCodec struct {
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecGrpcHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecGrpcHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecGrpcHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecGrpcHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecGrpcHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttp2HealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttp2HealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttp2HealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttp2HealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttp2HealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttp2HealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttpHealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttpHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttpHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttpHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttpsHealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttpsHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttpsHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttpsHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttpsHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttpsHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecLogConfigCodec struct {
}

func (RegionHealthCheckSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecLogConfig)(ptr) == nil
}

func (RegionHealthCheckSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecLogConfig)(ptr)
	var objs []RegionHealthCheckSpecLogConfig
	if obj != nil {
		objs = []RegionHealthCheckSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecLogConfig)(ptr) = RegionHealthCheckSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecLogConfig)(ptr) = RegionHealthCheckSpecLogConfig{}
			}
		} else {
			*(*RegionHealthCheckSpecLogConfig)(ptr) = RegionHealthCheckSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecLogConfig)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecLogConfig)(ptr) = RegionHealthCheckSpecLogConfig{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecSslHealthCheckCodec struct {
}

func (RegionHealthCheckSpecSslHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecSslHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecSslHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecSslHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecSslHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecSslHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecSslHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecSslHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecTcpHealthCheckCodec struct {
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecTcpHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecTcpHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecTcpHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecTcpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionHealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = obj
		} else {
			*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecTcpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec struct {
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr)
	var objs []RegionInstanceGroupManagerSpecAutoHealingPolicies
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecAutoHealingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionInstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = obj
		} else {
			*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecAutoHealingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecUpdatePolicyCodec struct {
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr)
	var objs []RegionInstanceGroupManagerSpecUpdatePolicy
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecUpdatePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionInstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = obj
		} else {
			*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecUpdatePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecVersionTargetSizeCodec struct {
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr)
	var objs []RegionInstanceGroupManagerSpecVersionTargetSize
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecVersionTargetSize{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionInstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = obj
		} else {
			*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecVersionTargetSize", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecAppEngineCodec struct {
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecAppEngine)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecAppEngine)(ptr)
	var objs []RegionNetworkEndpointGroupSpecAppEngine
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecAppEngine{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecAppEngine

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionNetworkEndpointGroupSpecAppEngine

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = obj
		} else {
			*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecAppEngine", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecCloudFunctionCodec struct {
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecCloudFunction)(ptr)
	var objs []RegionNetworkEndpointGroupSpecCloudFunction
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecCloudFunction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecCloudFunction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionNetworkEndpointGroupSpecCloudFunction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = obj
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecCloudFunction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecCloudRunCodec struct {
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecCloudRun)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecCloudRun)(ptr)
	var objs []RegionNetworkEndpointGroupSpecCloudRun
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecCloudRun{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecCloudRun

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionNetworkEndpointGroupSpecCloudRun

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = obj
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecCloudRun", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionPerInstanceConfigSpecPreservedStateCodec struct {
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionPerInstanceConfigSpecPreservedState)(ptr) == nil
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionPerInstanceConfigSpecPreservedState)(ptr)
	var objs []RegionPerInstanceConfigSpecPreservedState
	if obj != nil {
		objs = []RegionPerInstanceConfigSpecPreservedState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionPerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = objs[0]
			} else {
				*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
			}
		} else {
			*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionPerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = obj
		} else {
			*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
		}
	default:
		iter.ReportError("decode RegionPerInstanceConfigSpecPreservedState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecDefaultURLRedirectCodec struct {
}

func (RegionURLMapSpecDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecDefaultURLRedirect)(ptr) == nil
}

func (RegionURLMapSpecDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecDefaultURLRedirect)(ptr)
	var objs []RegionURLMapSpecDefaultURLRedirect
	if obj != nil {
		objs = []RegionURLMapSpecDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
			}
		} else {
			*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = obj
		} else {
			*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherDefaultURLRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherDefaultURLRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleUrlRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegionURLMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = obj
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ReservationSpecSpecificReservationCodec struct {
}

func (ReservationSpecSpecificReservationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ReservationSpecSpecificReservation)(ptr) == nil
}

func (ReservationSpecSpecificReservationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ReservationSpecSpecificReservation)(ptr)
	var objs []ReservationSpecSpecificReservation
	if obj != nil {
		objs = []ReservationSpecSpecificReservation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ReservationSpecSpecificReservationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ReservationSpecSpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ReservationSpecSpecificReservation)(ptr) = objs[0]
			} else {
				*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
			}
		} else {
			*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ReservationSpecSpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ReservationSpecSpecificReservation)(ptr) = obj
		} else {
			*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
		}
	default:
		iter.ReportError("decode ReservationSpecSpecificReservation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ReservationSpecSpecificReservationInstancePropertiesCodec struct {
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ReservationSpecSpecificReservationInstanceProperties)(ptr) == nil
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ReservationSpecSpecificReservationInstanceProperties)(ptr)
	var objs []ReservationSpecSpecificReservationInstanceProperties
	if obj != nil {
		objs = []ReservationSpecSpecificReservationInstanceProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ReservationSpecSpecificReservationInstanceProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = objs[0]
			} else {
				*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
			}
		} else {
			*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ReservationSpecSpecificReservationInstanceProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = obj
		} else {
			*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
		}
	default:
		iter.ReportError("decode ReservationSpecSpecificReservationInstanceProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecGroupPlacementPolicyCodec struct {
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecGroupPlacementPolicy)(ptr) == nil
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecGroupPlacementPolicy)(ptr)
	var objs []ResourcePolicySpecGroupPlacementPolicy
	if obj != nil {
		objs = []ResourcePolicySpecGroupPlacementPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecGroupPlacementPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
			}
		} else {
			*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecGroupPlacementPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = obj
		} else {
			*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecGroupPlacementPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecInstanceSchedulePolicyCodec struct {
}

func (ResourcePolicySpecInstanceSchedulePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecInstanceSchedulePolicy)(ptr) == nil
}

func (ResourcePolicySpecInstanceSchedulePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecInstanceSchedulePolicy)(ptr)
	var objs []ResourcePolicySpecInstanceSchedulePolicy
	if obj != nil {
		objs = []ResourcePolicySpecInstanceSchedulePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecInstanceSchedulePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = ResourcePolicySpecInstanceSchedulePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecInstanceSchedulePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = ResourcePolicySpecInstanceSchedulePolicy{}
			}
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = ResourcePolicySpecInstanceSchedulePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecInstanceSchedulePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = obj
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicy)(ptr) = ResourcePolicySpecInstanceSchedulePolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecInstanceSchedulePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec struct {
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) == nil
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr)
	var objs []ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule
	if obj != nil {
		objs = []ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStartScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}
			}
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecInstanceSchedulePolicyVmStartSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec struct {
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) == nil
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr)
	var objs []ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule
	if obj != nil {
		objs = []ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecInstanceSchedulePolicyVmStopScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}
			}
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule)(ptr) = ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecInstanceSchedulePolicyVmStopSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicy)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicy
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = obj
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouterSpecBgpCodec struct {
}

func (RouterSpecBgpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouterSpecBgp)(ptr) == nil
}

func (RouterSpecBgpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouterSpecBgp)(ptr)
	var objs []RouterSpecBgp
	if obj != nil {
		objs = []RouterSpecBgp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouterSpecBgpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouterSpecBgp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouterSpecBgp)(ptr) = objs[0]
			} else {
				*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
			}
		} else {
			*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RouterSpecBgp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RouterSpecBgp)(ptr) = obj
		} else {
			*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
		}
	default:
		iter.ReportError("decode RouterSpecBgp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouterNATSpecLogConfigCodec struct {
}

func (RouterNATSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouterNATSpecLogConfig)(ptr) == nil
}

func (RouterNATSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouterNATSpecLogConfig)(ptr)
	var objs []RouterNATSpecLogConfig
	if obj != nil {
		objs = []RouterNATSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouterNATSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouterNATSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouterNATSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
			}
		} else {
			*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RouterNATSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RouterNATSpecLogConfig)(ptr) = obj
		} else {
			*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
		}
	default:
		iter.ReportError("decode RouterNATSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchCodec struct {
}

func (SecurityPolicySpecRuleMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatch)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatch)(ptr)
	var objs []SecurityPolicySpecRuleMatch
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatch)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityPolicySpecRuleMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityPolicySpecRuleMatch)(ptr) = obj
		} else {
			*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchConfigCodec struct {
}

func (SecurityPolicySpecRuleMatchConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatchConfig)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatchConfig)(ptr)
	var objs []SecurityPolicySpecRuleMatchConfig
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatchConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatchConfig)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityPolicySpecRuleMatchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityPolicySpecRuleMatchConfig)(ptr) = obj
		} else {
			*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatchConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchExprCodec struct {
}

func (SecurityPolicySpecRuleMatchExprCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatchExpr)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchExprCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatchExpr)(ptr)
	var objs []SecurityPolicySpecRuleMatchExpr
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatchExpr{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchExprCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatchExpr

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatchExpr)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityPolicySpecRuleMatchExpr

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityPolicySpecRuleMatchExpr)(ptr) = obj
		} else {
			*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatchExpr", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SnapshotSpecSnapshotEncryptionKeyCodec struct {
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SnapshotSpecSnapshotEncryptionKey)(ptr) == nil
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SnapshotSpecSnapshotEncryptionKey)(ptr)
	var objs []SnapshotSpecSnapshotEncryptionKey
	if obj != nil {
		objs = []SnapshotSpecSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SnapshotSpecSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
			}
		} else {
			*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SnapshotSpecSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = obj
		} else {
			*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode SnapshotSpecSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SnapshotSpecSourceDiskEncryptionKeyCodec struct {
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SnapshotSpecSourceDiskEncryptionKey)(ptr) == nil
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SnapshotSpecSourceDiskEncryptionKey)(ptr)
	var objs []SnapshotSpecSourceDiskEncryptionKey
	if obj != nil {
		objs = []SnapshotSpecSourceDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SnapshotSpecSourceDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
			}
		} else {
			*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SnapshotSpecSourceDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = obj
		} else {
			*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode SnapshotSpecSourceDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkSpecLogConfigCodec struct {
}

func (SubnetworkSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkSpecLogConfig)(ptr) == nil
}

func (SubnetworkSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkSpecLogConfig)(ptr)
	var objs []SubnetworkSpecLogConfig
	if obj != nil {
		objs = []SubnetworkSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
			}
		} else {
			*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SubnetworkSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SubnetworkSpecLogConfig)(ptr) = obj
		} else {
			*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
		}
	default:
		iter.ReportError("decode SubnetworkSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkIamBindingSpecConditionCodec struct {
}

func (SubnetworkIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkIamBindingSpecCondition)(ptr) == nil
}

func (SubnetworkIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkIamBindingSpecCondition)(ptr)
	var objs []SubnetworkIamBindingSpecCondition
	if obj != nil {
		objs = []SubnetworkIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
			}
		} else {
			*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SubnetworkIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SubnetworkIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode SubnetworkIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkIamMemberSpecConditionCodec struct {
}

func (SubnetworkIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkIamMemberSpecCondition)(ptr) == nil
}

func (SubnetworkIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkIamMemberSpecCondition)(ptr)
	var objs []SubnetworkIamMemberSpecCondition
	if obj != nil {
		objs = []SubnetworkIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
			}
		} else {
			*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SubnetworkIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SubnetworkIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode SubnetworkIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionCodec struct {
}

func (UrlMapSpecDefaultRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteAction)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteAction)(ptr)
	var objs []UrlMapSpecDefaultRouteAction
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteAction)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionTimeoutCodec struct {
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionTimeout)(ptr)
	var objs []UrlMapSpecDefaultRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecDefaultRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultURLRedirectCodec struct {
}

func (UrlMapSpecDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultURLRedirect)(ptr) == nil
}

func (UrlMapSpecDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultURLRedirect)(ptr)
	var objs []UrlMapSpecDefaultURLRedirect
	if obj != nil {
		objs = []UrlMapSpecDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
			}
		} else {
			*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecDefaultURLRedirect)(ptr) = obj
		} else {
			*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecHeaderActionCodec struct {
}

func (UrlMapSpecHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecHeaderAction)(ptr) == nil
}

func (UrlMapSpecHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecHeaderAction)(ptr)
	var objs []UrlMapSpecHeaderAction
	if obj != nil {
		objs = []UrlMapSpecHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
			}
		} else {
			*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultURLRedirectCodec struct {
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultURLRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleUrlRedirectCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleUrlRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesUrlRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj UrlMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = obj
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesUrlRedirect", "unexpected JSON type")
	}
}
