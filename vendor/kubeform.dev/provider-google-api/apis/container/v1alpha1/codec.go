/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1()):                    AnalysisNoteSpecAttestationAuthorityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1()):                AnalysisNoteSpecAttestationAuthorityHintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1()):                       AnalysisOccurrenceSpecAttestationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecAuthorization{}).Type1()):                             AwsClusterSpecAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlane{}).Type1()):                              AwsClusterSpecControlPlaneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneAwsServicesAuthentication{}).Type1()):     AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneConfigEncryption{}).Type1()):              AwsClusterSpecControlPlaneConfigEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneDatabaseEncryption{}).Type1()):            AwsClusterSpecControlPlaneDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneMainVolume{}).Type1()):                    AwsClusterSpecControlPlaneMainVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneProxyConfig{}).Type1()):                   AwsClusterSpecControlPlaneProxyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneRootVolume{}).Type1()):                    AwsClusterSpecControlPlaneRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneSshConfig{}).Type1()):                     AwsClusterSpecControlPlaneSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecFleet{}).Type1()):                                     AwsClusterSpecFleetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecNetworking{}).Type1()):                                AwsClusterSpecNetworkingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecAutoscaling{}).Type1()):                              AwsNodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfig{}).Type1()):                                   AwsNodePoolSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigConfigEncryption{}).Type1()):                   AwsNodePoolSpecConfigConfigEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigRootVolume{}).Type1()):                         AwsNodePoolSpecConfigRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigSshConfig{}).Type1()):                          AwsNodePoolSpecConfigSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecMaxPodsConstraint{}).Type1()):                        AwsNodePoolSpecMaxPodsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecAuthorization{}).Type1()):                           AzureClusterSpecAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlane{}).Type1()):                            AzureClusterSpecControlPlaneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneDatabaseEncryption{}).Type1()):          AzureClusterSpecControlPlaneDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneMainVolume{}).Type1()):                  AzureClusterSpecControlPlaneMainVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneProxyConfig{}).Type1()):                 AzureClusterSpecControlPlaneProxyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneRootVolume{}).Type1()):                  AzureClusterSpecControlPlaneRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneSshConfig{}).Type1()):                   AzureClusterSpecControlPlaneSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecFleet{}).Type1()):                                   AzureClusterSpecFleetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecNetworking{}).Type1()):                              AzureClusterSpecNetworkingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecAutoscaling{}).Type1()):                            AzureNodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfig{}).Type1()):                                 AzureNodePoolSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigRootVolume{}).Type1()):                       AzureNodePoolSpecConfigRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigSshConfig{}).Type1()):                        AzureNodePoolSpecConfigSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecMaxPodsConstraint{}).Type1()):                      AzureNodePoolSpecMaxPodsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1()):                                 ClusterSpecAddonsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1()):                   ClusterSpecAddonsConfigCloudrunConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}).Type1()):      ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1()):         ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1()):                ClusterSpecAddonsConfigHttpLoadBalancingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1()):              ClusterSpecAddonsConfigNetworkPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1()):                    ClusterSpecAuthenticatorGroupsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1()):                           ClusterSpecClusterAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1()):   ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfidentialNodes{}).Type1()):                            ClusterSpecConfidentialNodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1()):                           ClusterSpecDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1()):                            ClusterSpecDefaultSnatStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDnsConfig{}).Type1()):                                    ClusterSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1()):                           ClusterSpecIpAllocationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingConfig{}).Type1()):                                ClusterSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1()):                            ClusterSpecMaintenancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1()):      ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1()):             ClusterSpecMaintenancePolicyRecurringWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1()):                                   ClusterSpecMasterAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1()):            ClusterSpecMasterAuthClientCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1()):               ClusterSpecMasterAuthorizedNetworksConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMonitoringConfig{}).Type1()):                             ClusterSpecMonitoringConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1()):                                ClusterSpecNetworkPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1()):                                   ClusterSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigGcfsConfig{}).Type1()):                         ClusterSpecNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1()):             ClusterSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1()):             ClusterSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1()):                          ClusterSpecNodePoolAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1()):                           ClusterSpecNodePoolManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1()):                           ClusterSpecNodePoolNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigGcfsConfig{}).Type1()):                 ClusterSpecNodePoolNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1()):                      ClusterSpecNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1()):                         ClusterSpecPrivateClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1()): ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1()):                               ClusterSpecReleaseChannelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1()):                    ClusterSpecResourceUsageExportConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1()): ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1()):                       ClusterSpecVerticalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1()):                       ClusterSpecWorkloadIdentityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1()):                                 NodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1()):                                  NodePoolSpecManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1()):                                  NodePoolSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigGcfsConfig{}).Type1()):                        NodePoolSpecNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1()):            NodePoolSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1()):            NodePoolSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                             NodePoolSpecUpgradeSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1()):                    AnalysisNoteSpecAttestationAuthorityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1()):                AnalysisNoteSpecAttestationAuthorityHintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1()):                       AnalysisOccurrenceSpecAttestationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecAuthorization{}).Type1()):                             AwsClusterSpecAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlane{}).Type1()):                              AwsClusterSpecControlPlaneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneAwsServicesAuthentication{}).Type1()):     AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneConfigEncryption{}).Type1()):              AwsClusterSpecControlPlaneConfigEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneDatabaseEncryption{}).Type1()):            AwsClusterSpecControlPlaneDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneMainVolume{}).Type1()):                    AwsClusterSpecControlPlaneMainVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneProxyConfig{}).Type1()):                   AwsClusterSpecControlPlaneProxyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneRootVolume{}).Type1()):                    AwsClusterSpecControlPlaneRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneSshConfig{}).Type1()):                     AwsClusterSpecControlPlaneSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecFleet{}).Type1()):                                     AwsClusterSpecFleetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecNetworking{}).Type1()):                                AwsClusterSpecNetworkingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecAutoscaling{}).Type1()):                              AwsNodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfig{}).Type1()):                                   AwsNodePoolSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigConfigEncryption{}).Type1()):                   AwsNodePoolSpecConfigConfigEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigRootVolume{}).Type1()):                         AwsNodePoolSpecConfigRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigSshConfig{}).Type1()):                          AwsNodePoolSpecConfigSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecMaxPodsConstraint{}).Type1()):                        AwsNodePoolSpecMaxPodsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecAuthorization{}).Type1()):                           AzureClusterSpecAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlane{}).Type1()):                            AzureClusterSpecControlPlaneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneDatabaseEncryption{}).Type1()):          AzureClusterSpecControlPlaneDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneMainVolume{}).Type1()):                  AzureClusterSpecControlPlaneMainVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneProxyConfig{}).Type1()):                 AzureClusterSpecControlPlaneProxyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneRootVolume{}).Type1()):                  AzureClusterSpecControlPlaneRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneSshConfig{}).Type1()):                   AzureClusterSpecControlPlaneSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecFleet{}).Type1()):                                   AzureClusterSpecFleetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecNetworking{}).Type1()):                              AzureClusterSpecNetworkingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecAutoscaling{}).Type1()):                            AzureNodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfig{}).Type1()):                                 AzureNodePoolSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigRootVolume{}).Type1()):                       AzureNodePoolSpecConfigRootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigSshConfig{}).Type1()):                        AzureNodePoolSpecConfigSshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecMaxPodsConstraint{}).Type1()):                      AzureNodePoolSpecMaxPodsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1()):                                 ClusterSpecAddonsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1()):                   ClusterSpecAddonsConfigCloudrunConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}).Type1()):      ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1()):         ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1()):                ClusterSpecAddonsConfigHttpLoadBalancingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1()):              ClusterSpecAddonsConfigNetworkPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1()):                    ClusterSpecAuthenticatorGroupsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1()):                           ClusterSpecClusterAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1()):   ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfidentialNodes{}).Type1()):                            ClusterSpecConfidentialNodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1()):                           ClusterSpecDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1()):                            ClusterSpecDefaultSnatStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDnsConfig{}).Type1()):                                    ClusterSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1()):                           ClusterSpecIpAllocationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingConfig{}).Type1()):                                ClusterSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1()):                            ClusterSpecMaintenancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1()):      ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1()):             ClusterSpecMaintenancePolicyRecurringWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1()):                                   ClusterSpecMasterAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1()):            ClusterSpecMasterAuthClientCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1()):               ClusterSpecMasterAuthorizedNetworksConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMonitoringConfig{}).Type1()):                             ClusterSpecMonitoringConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1()):                                ClusterSpecNetworkPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1()):                                   ClusterSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigGcfsConfig{}).Type1()):                         ClusterSpecNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1()):             ClusterSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1()):             ClusterSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1()):                          ClusterSpecNodePoolAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1()):                           ClusterSpecNodePoolManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1()):                           ClusterSpecNodePoolNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigGcfsConfig{}).Type1()):                 ClusterSpecNodePoolNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1()):                      ClusterSpecNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1()):                         ClusterSpecPrivateClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1()): ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1()):                               ClusterSpecReleaseChannelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1()):                    ClusterSpecResourceUsageExportConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1()): ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1()):                       ClusterSpecVerticalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1()):                       ClusterSpecWorkloadIdentityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1()):                                 NodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1()):                                  NodePoolSpecManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1()):                                  NodePoolSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigGcfsConfig{}).Type1()):                        NodePoolSpecNodeConfigGcfsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1()):            NodePoolSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1()):            NodePoolSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                             NodePoolSpecUpgradeSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnalysisNoteSpecAttestationAuthorityCodec struct {
}

func (AnalysisNoteSpecAttestationAuthorityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisNoteSpecAttestationAuthority)(ptr) == nil
}

func (AnalysisNoteSpecAttestationAuthorityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisNoteSpecAttestationAuthority)(ptr)
	var objs []AnalysisNoteSpecAttestationAuthority
	if obj != nil {
		objs = []AnalysisNoteSpecAttestationAuthority{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisNoteSpecAttestationAuthorityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisNoteSpecAttestationAuthority

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisNoteSpecAttestationAuthority)(ptr) = objs[0]
			} else {
				*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
			}
		} else {
			*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnalysisNoteSpecAttestationAuthority

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnalysisNoteSpecAttestationAuthority)(ptr) = obj
		} else {
			*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
		}
	default:
		iter.ReportError("decode AnalysisNoteSpecAttestationAuthority", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalysisNoteSpecAttestationAuthorityHintCodec struct {
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisNoteSpecAttestationAuthorityHint)(ptr) == nil
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisNoteSpecAttestationAuthorityHint)(ptr)
	var objs []AnalysisNoteSpecAttestationAuthorityHint
	if obj != nil {
		objs = []AnalysisNoteSpecAttestationAuthorityHint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisNoteSpecAttestationAuthorityHint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = objs[0]
			} else {
				*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
			}
		} else {
			*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnalysisNoteSpecAttestationAuthorityHint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = obj
		} else {
			*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
		}
	default:
		iter.ReportError("decode AnalysisNoteSpecAttestationAuthorityHint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalysisOccurrenceSpecAttestationCodec struct {
}

func (AnalysisOccurrenceSpecAttestationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisOccurrenceSpecAttestation)(ptr) == nil
}

func (AnalysisOccurrenceSpecAttestationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisOccurrenceSpecAttestation)(ptr)
	var objs []AnalysisOccurrenceSpecAttestation
	if obj != nil {
		objs = []AnalysisOccurrenceSpecAttestation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisOccurrenceSpecAttestationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisOccurrenceSpecAttestation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisOccurrenceSpecAttestation)(ptr) = objs[0]
			} else {
				*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
			}
		} else {
			*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnalysisOccurrenceSpecAttestation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnalysisOccurrenceSpecAttestation)(ptr) = obj
		} else {
			*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
		}
	default:
		iter.ReportError("decode AnalysisOccurrenceSpecAttestation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecAuthorizationCodec struct {
}

func (AwsClusterSpecAuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecAuthorization)(ptr) == nil
}

func (AwsClusterSpecAuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecAuthorization)(ptr)
	var objs []AwsClusterSpecAuthorization
	if obj != nil {
		objs = []AwsClusterSpecAuthorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecAuthorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecAuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecAuthorization)(ptr) = AwsClusterSpecAuthorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecAuthorization)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecAuthorization)(ptr) = AwsClusterSpecAuthorization{}
			}
		} else {
			*(*AwsClusterSpecAuthorization)(ptr) = AwsClusterSpecAuthorization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecAuthorization)(ptr) = obj
		} else {
			*(*AwsClusterSpecAuthorization)(ptr) = AwsClusterSpecAuthorization{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecAuthorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneCodec struct {
}

func (AwsClusterSpecControlPlaneCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlane)(ptr) == nil
}

func (AwsClusterSpecControlPlaneCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlane)(ptr)
	var objs []AwsClusterSpecControlPlane
	if obj != nil {
		objs = []AwsClusterSpecControlPlane{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlane{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlane)(ptr) = AwsClusterSpecControlPlane{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlane

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlane{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlane)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlane)(ptr) = AwsClusterSpecControlPlane{}
			}
		} else {
			*(*AwsClusterSpecControlPlane)(ptr) = AwsClusterSpecControlPlane{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlane

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlane{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlane)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlane)(ptr) = AwsClusterSpecControlPlane{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlane", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec struct {
}

func (AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) == nil
}

func (AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr)
	var objs []AwsClusterSpecControlPlaneAwsServicesAuthentication
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneAwsServicesAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneAwsServicesAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneAwsServicesAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = AwsClusterSpecControlPlaneAwsServicesAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneAwsServicesAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneAwsServicesAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = AwsClusterSpecControlPlaneAwsServicesAuthentication{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = AwsClusterSpecControlPlaneAwsServicesAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneAwsServicesAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneAwsServicesAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneAwsServicesAuthentication)(ptr) = AwsClusterSpecControlPlaneAwsServicesAuthentication{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneAwsServicesAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneConfigEncryptionCodec struct {
}

func (AwsClusterSpecControlPlaneConfigEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneConfigEncryption)(ptr) == nil
}

func (AwsClusterSpecControlPlaneConfigEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneConfigEncryption)(ptr)
	var objs []AwsClusterSpecControlPlaneConfigEncryption
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneConfigEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneConfigEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneConfigEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = AwsClusterSpecControlPlaneConfigEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneConfigEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneConfigEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = AwsClusterSpecControlPlaneConfigEncryption{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = AwsClusterSpecControlPlaneConfigEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneConfigEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneConfigEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneConfigEncryption)(ptr) = AwsClusterSpecControlPlaneConfigEncryption{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneConfigEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneDatabaseEncryptionCodec struct {
}

func (AwsClusterSpecControlPlaneDatabaseEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) == nil
}

func (AwsClusterSpecControlPlaneDatabaseEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr)
	var objs []AwsClusterSpecControlPlaneDatabaseEncryption
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneDatabaseEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneDatabaseEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = AwsClusterSpecControlPlaneDatabaseEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = AwsClusterSpecControlPlaneDatabaseEncryption{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = AwsClusterSpecControlPlaneDatabaseEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneDatabaseEncryption)(ptr) = AwsClusterSpecControlPlaneDatabaseEncryption{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneDatabaseEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneMainVolumeCodec struct {
}

func (AwsClusterSpecControlPlaneMainVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneMainVolume)(ptr) == nil
}

func (AwsClusterSpecControlPlaneMainVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneMainVolume)(ptr)
	var objs []AwsClusterSpecControlPlaneMainVolume
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneMainVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneMainVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneMainVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = AwsClusterSpecControlPlaneMainVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneMainVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneMainVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = AwsClusterSpecControlPlaneMainVolume{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = AwsClusterSpecControlPlaneMainVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneMainVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneMainVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneMainVolume)(ptr) = AwsClusterSpecControlPlaneMainVolume{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneMainVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneProxyConfigCodec struct {
}

func (AwsClusterSpecControlPlaneProxyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneProxyConfig)(ptr) == nil
}

func (AwsClusterSpecControlPlaneProxyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneProxyConfig)(ptr)
	var objs []AwsClusterSpecControlPlaneProxyConfig
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneProxyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneProxyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneProxyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = AwsClusterSpecControlPlaneProxyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneProxyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneProxyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = AwsClusterSpecControlPlaneProxyConfig{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = AwsClusterSpecControlPlaneProxyConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneProxyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneProxyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneProxyConfig)(ptr) = AwsClusterSpecControlPlaneProxyConfig{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneProxyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneRootVolumeCodec struct {
}

func (AwsClusterSpecControlPlaneRootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneRootVolume)(ptr) == nil
}

func (AwsClusterSpecControlPlaneRootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneRootVolume)(ptr)
	var objs []AwsClusterSpecControlPlaneRootVolume
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneRootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneRootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneRootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = AwsClusterSpecControlPlaneRootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = AwsClusterSpecControlPlaneRootVolume{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = AwsClusterSpecControlPlaneRootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneRootVolume)(ptr) = AwsClusterSpecControlPlaneRootVolume{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneRootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecControlPlaneSshConfigCodec struct {
}

func (AwsClusterSpecControlPlaneSshConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecControlPlaneSshConfig)(ptr) == nil
}

func (AwsClusterSpecControlPlaneSshConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecControlPlaneSshConfig)(ptr)
	var objs []AwsClusterSpecControlPlaneSshConfig
	if obj != nil {
		objs = []AwsClusterSpecControlPlaneSshConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneSshConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecControlPlaneSshConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = AwsClusterSpecControlPlaneSshConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecControlPlaneSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = AwsClusterSpecControlPlaneSshConfig{}
			}
		} else {
			*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = AwsClusterSpecControlPlaneSshConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecControlPlaneSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecControlPlaneSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = obj
		} else {
			*(*AwsClusterSpecControlPlaneSshConfig)(ptr) = AwsClusterSpecControlPlaneSshConfig{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecControlPlaneSshConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecFleetCodec struct {
}

func (AwsClusterSpecFleetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecFleet)(ptr) == nil
}

func (AwsClusterSpecFleetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecFleet)(ptr)
	var objs []AwsClusterSpecFleet
	if obj != nil {
		objs = []AwsClusterSpecFleet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecFleet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecFleetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecFleet)(ptr) = AwsClusterSpecFleet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecFleet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecFleet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecFleet)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecFleet)(ptr) = AwsClusterSpecFleet{}
			}
		} else {
			*(*AwsClusterSpecFleet)(ptr) = AwsClusterSpecFleet{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecFleet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecFleet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecFleet)(ptr) = obj
		} else {
			*(*AwsClusterSpecFleet)(ptr) = AwsClusterSpecFleet{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecFleet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsClusterSpecNetworkingCodec struct {
}

func (AwsClusterSpecNetworkingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsClusterSpecNetworking)(ptr) == nil
}

func (AwsClusterSpecNetworkingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsClusterSpecNetworking)(ptr)
	var objs []AwsClusterSpecNetworking
	if obj != nil {
		objs = []AwsClusterSpecNetworking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecNetworking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsClusterSpecNetworkingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsClusterSpecNetworking)(ptr) = AwsClusterSpecNetworking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsClusterSpecNetworking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecNetworking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsClusterSpecNetworking)(ptr) = objs[0]
			} else {
				*(*AwsClusterSpecNetworking)(ptr) = AwsClusterSpecNetworking{}
			}
		} else {
			*(*AwsClusterSpecNetworking)(ptr) = AwsClusterSpecNetworking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsClusterSpecNetworking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsClusterSpecNetworking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsClusterSpecNetworking)(ptr) = obj
		} else {
			*(*AwsClusterSpecNetworking)(ptr) = AwsClusterSpecNetworking{}
		}
	default:
		iter.ReportError("decode AwsClusterSpecNetworking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecAutoscalingCodec struct {
}

func (AwsNodePoolSpecAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecAutoscaling)(ptr) == nil
}

func (AwsNodePoolSpecAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecAutoscaling)(ptr)
	var objs []AwsNodePoolSpecAutoscaling
	if obj != nil {
		objs = []AwsNodePoolSpecAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecAutoscaling)(ptr) = AwsNodePoolSpecAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecAutoscaling)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecAutoscaling)(ptr) = AwsNodePoolSpecAutoscaling{}
			}
		} else {
			*(*AwsNodePoolSpecAutoscaling)(ptr) = AwsNodePoolSpecAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecAutoscaling)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecAutoscaling)(ptr) = AwsNodePoolSpecAutoscaling{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecConfigCodec struct {
}

func (AwsNodePoolSpecConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecConfig)(ptr) == nil
}

func (AwsNodePoolSpecConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecConfig)(ptr)
	var objs []AwsNodePoolSpecConfig
	if obj != nil {
		objs = []AwsNodePoolSpecConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecConfig)(ptr) = AwsNodePoolSpecConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecConfig)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecConfig)(ptr) = AwsNodePoolSpecConfig{}
			}
		} else {
			*(*AwsNodePoolSpecConfig)(ptr) = AwsNodePoolSpecConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecConfig)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecConfig)(ptr) = AwsNodePoolSpecConfig{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecConfigConfigEncryptionCodec struct {
}

func (AwsNodePoolSpecConfigConfigEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecConfigConfigEncryption)(ptr) == nil
}

func (AwsNodePoolSpecConfigConfigEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecConfigConfigEncryption)(ptr)
	var objs []AwsNodePoolSpecConfigConfigEncryption
	if obj != nil {
		objs = []AwsNodePoolSpecConfigConfigEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigConfigEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecConfigConfigEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = AwsNodePoolSpecConfigConfigEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecConfigConfigEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigConfigEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = AwsNodePoolSpecConfigConfigEncryption{}
			}
		} else {
			*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = AwsNodePoolSpecConfigConfigEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecConfigConfigEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigConfigEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecConfigConfigEncryption)(ptr) = AwsNodePoolSpecConfigConfigEncryption{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecConfigConfigEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecConfigRootVolumeCodec struct {
}

func (AwsNodePoolSpecConfigRootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecConfigRootVolume)(ptr) == nil
}

func (AwsNodePoolSpecConfigRootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecConfigRootVolume)(ptr)
	var objs []AwsNodePoolSpecConfigRootVolume
	if obj != nil {
		objs = []AwsNodePoolSpecConfigRootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigRootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecConfigRootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecConfigRootVolume)(ptr) = AwsNodePoolSpecConfigRootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecConfigRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecConfigRootVolume)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecConfigRootVolume)(ptr) = AwsNodePoolSpecConfigRootVolume{}
			}
		} else {
			*(*AwsNodePoolSpecConfigRootVolume)(ptr) = AwsNodePoolSpecConfigRootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecConfigRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecConfigRootVolume)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecConfigRootVolume)(ptr) = AwsNodePoolSpecConfigRootVolume{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecConfigRootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecConfigSshConfigCodec struct {
}

func (AwsNodePoolSpecConfigSshConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecConfigSshConfig)(ptr) == nil
}

func (AwsNodePoolSpecConfigSshConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecConfigSshConfig)(ptr)
	var objs []AwsNodePoolSpecConfigSshConfig
	if obj != nil {
		objs = []AwsNodePoolSpecConfigSshConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigSshConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecConfigSshConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecConfigSshConfig)(ptr) = AwsNodePoolSpecConfigSshConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecConfigSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecConfigSshConfig)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecConfigSshConfig)(ptr) = AwsNodePoolSpecConfigSshConfig{}
			}
		} else {
			*(*AwsNodePoolSpecConfigSshConfig)(ptr) = AwsNodePoolSpecConfigSshConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecConfigSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecConfigSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecConfigSshConfig)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecConfigSshConfig)(ptr) = AwsNodePoolSpecConfigSshConfig{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecConfigSshConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AwsNodePoolSpecMaxPodsConstraintCodec struct {
}

func (AwsNodePoolSpecMaxPodsConstraintCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AwsNodePoolSpecMaxPodsConstraint)(ptr) == nil
}

func (AwsNodePoolSpecMaxPodsConstraintCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AwsNodePoolSpecMaxPodsConstraint)(ptr)
	var objs []AwsNodePoolSpecMaxPodsConstraint
	if obj != nil {
		objs = []AwsNodePoolSpecMaxPodsConstraint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecMaxPodsConstraint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AwsNodePoolSpecMaxPodsConstraintCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = AwsNodePoolSpecMaxPodsConstraint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AwsNodePoolSpecMaxPodsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecMaxPodsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = objs[0]
			} else {
				*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = AwsNodePoolSpecMaxPodsConstraint{}
			}
		} else {
			*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = AwsNodePoolSpecMaxPodsConstraint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AwsNodePoolSpecMaxPodsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AwsNodePoolSpecMaxPodsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = obj
		} else {
			*(*AwsNodePoolSpecMaxPodsConstraint)(ptr) = AwsNodePoolSpecMaxPodsConstraint{}
		}
	default:
		iter.ReportError("decode AwsNodePoolSpecMaxPodsConstraint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecAuthorizationCodec struct {
}

func (AzureClusterSpecAuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecAuthorization)(ptr) == nil
}

func (AzureClusterSpecAuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecAuthorization)(ptr)
	var objs []AzureClusterSpecAuthorization
	if obj != nil {
		objs = []AzureClusterSpecAuthorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecAuthorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecAuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecAuthorization)(ptr) = AzureClusterSpecAuthorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecAuthorization)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecAuthorization)(ptr) = AzureClusterSpecAuthorization{}
			}
		} else {
			*(*AzureClusterSpecAuthorization)(ptr) = AzureClusterSpecAuthorization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecAuthorization)(ptr) = obj
		} else {
			*(*AzureClusterSpecAuthorization)(ptr) = AzureClusterSpecAuthorization{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecAuthorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneCodec struct {
}

func (AzureClusterSpecControlPlaneCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlane)(ptr) == nil
}

func (AzureClusterSpecControlPlaneCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlane)(ptr)
	var objs []AzureClusterSpecControlPlane
	if obj != nil {
		objs = []AzureClusterSpecControlPlane{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlane{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlane)(ptr) = AzureClusterSpecControlPlane{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlane

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlane{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlane)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlane)(ptr) = AzureClusterSpecControlPlane{}
			}
		} else {
			*(*AzureClusterSpecControlPlane)(ptr) = AzureClusterSpecControlPlane{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlane

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlane{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlane)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlane)(ptr) = AzureClusterSpecControlPlane{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlane", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneDatabaseEncryptionCodec struct {
}

func (AzureClusterSpecControlPlaneDatabaseEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) == nil
}

func (AzureClusterSpecControlPlaneDatabaseEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr)
	var objs []AzureClusterSpecControlPlaneDatabaseEncryption
	if obj != nil {
		objs = []AzureClusterSpecControlPlaneDatabaseEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneDatabaseEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = AzureClusterSpecControlPlaneDatabaseEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlaneDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = AzureClusterSpecControlPlaneDatabaseEncryption{}
			}
		} else {
			*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = AzureClusterSpecControlPlaneDatabaseEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlaneDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlaneDatabaseEncryption)(ptr) = AzureClusterSpecControlPlaneDatabaseEncryption{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlaneDatabaseEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneMainVolumeCodec struct {
}

func (AzureClusterSpecControlPlaneMainVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlaneMainVolume)(ptr) == nil
}

func (AzureClusterSpecControlPlaneMainVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlaneMainVolume)(ptr)
	var objs []AzureClusterSpecControlPlaneMainVolume
	if obj != nil {
		objs = []AzureClusterSpecControlPlaneMainVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneMainVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneMainVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = AzureClusterSpecControlPlaneMainVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlaneMainVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneMainVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = AzureClusterSpecControlPlaneMainVolume{}
			}
		} else {
			*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = AzureClusterSpecControlPlaneMainVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlaneMainVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneMainVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlaneMainVolume)(ptr) = AzureClusterSpecControlPlaneMainVolume{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlaneMainVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneProxyConfigCodec struct {
}

func (AzureClusterSpecControlPlaneProxyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlaneProxyConfig)(ptr) == nil
}

func (AzureClusterSpecControlPlaneProxyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlaneProxyConfig)(ptr)
	var objs []AzureClusterSpecControlPlaneProxyConfig
	if obj != nil {
		objs = []AzureClusterSpecControlPlaneProxyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneProxyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneProxyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = AzureClusterSpecControlPlaneProxyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlaneProxyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneProxyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = AzureClusterSpecControlPlaneProxyConfig{}
			}
		} else {
			*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = AzureClusterSpecControlPlaneProxyConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlaneProxyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneProxyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlaneProxyConfig)(ptr) = AzureClusterSpecControlPlaneProxyConfig{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlaneProxyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneRootVolumeCodec struct {
}

func (AzureClusterSpecControlPlaneRootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlaneRootVolume)(ptr) == nil
}

func (AzureClusterSpecControlPlaneRootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlaneRootVolume)(ptr)
	var objs []AzureClusterSpecControlPlaneRootVolume
	if obj != nil {
		objs = []AzureClusterSpecControlPlaneRootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneRootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneRootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = AzureClusterSpecControlPlaneRootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlaneRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = AzureClusterSpecControlPlaneRootVolume{}
			}
		} else {
			*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = AzureClusterSpecControlPlaneRootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlaneRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlaneRootVolume)(ptr) = AzureClusterSpecControlPlaneRootVolume{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlaneRootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecControlPlaneSshConfigCodec struct {
}

func (AzureClusterSpecControlPlaneSshConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecControlPlaneSshConfig)(ptr) == nil
}

func (AzureClusterSpecControlPlaneSshConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecControlPlaneSshConfig)(ptr)
	var objs []AzureClusterSpecControlPlaneSshConfig
	if obj != nil {
		objs = []AzureClusterSpecControlPlaneSshConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneSshConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecControlPlaneSshConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = AzureClusterSpecControlPlaneSshConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecControlPlaneSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = AzureClusterSpecControlPlaneSshConfig{}
			}
		} else {
			*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = AzureClusterSpecControlPlaneSshConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecControlPlaneSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecControlPlaneSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = obj
		} else {
			*(*AzureClusterSpecControlPlaneSshConfig)(ptr) = AzureClusterSpecControlPlaneSshConfig{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecControlPlaneSshConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecFleetCodec struct {
}

func (AzureClusterSpecFleetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecFleet)(ptr) == nil
}

func (AzureClusterSpecFleetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecFleet)(ptr)
	var objs []AzureClusterSpecFleet
	if obj != nil {
		objs = []AzureClusterSpecFleet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecFleet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecFleetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecFleet)(ptr) = AzureClusterSpecFleet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecFleet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecFleet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecFleet)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecFleet)(ptr) = AzureClusterSpecFleet{}
			}
		} else {
			*(*AzureClusterSpecFleet)(ptr) = AzureClusterSpecFleet{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecFleet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecFleet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecFleet)(ptr) = obj
		} else {
			*(*AzureClusterSpecFleet)(ptr) = AzureClusterSpecFleet{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecFleet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureClusterSpecNetworkingCodec struct {
}

func (AzureClusterSpecNetworkingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureClusterSpecNetworking)(ptr) == nil
}

func (AzureClusterSpecNetworkingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureClusterSpecNetworking)(ptr)
	var objs []AzureClusterSpecNetworking
	if obj != nil {
		objs = []AzureClusterSpecNetworking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecNetworking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureClusterSpecNetworkingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureClusterSpecNetworking)(ptr) = AzureClusterSpecNetworking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureClusterSpecNetworking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecNetworking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureClusterSpecNetworking)(ptr) = objs[0]
			} else {
				*(*AzureClusterSpecNetworking)(ptr) = AzureClusterSpecNetworking{}
			}
		} else {
			*(*AzureClusterSpecNetworking)(ptr) = AzureClusterSpecNetworking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureClusterSpecNetworking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureClusterSpecNetworking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureClusterSpecNetworking)(ptr) = obj
		} else {
			*(*AzureClusterSpecNetworking)(ptr) = AzureClusterSpecNetworking{}
		}
	default:
		iter.ReportError("decode AzureClusterSpecNetworking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureNodePoolSpecAutoscalingCodec struct {
}

func (AzureNodePoolSpecAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureNodePoolSpecAutoscaling)(ptr) == nil
}

func (AzureNodePoolSpecAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureNodePoolSpecAutoscaling)(ptr)
	var objs []AzureNodePoolSpecAutoscaling
	if obj != nil {
		objs = []AzureNodePoolSpecAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureNodePoolSpecAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureNodePoolSpecAutoscaling)(ptr) = AzureNodePoolSpecAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureNodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureNodePoolSpecAutoscaling)(ptr) = objs[0]
			} else {
				*(*AzureNodePoolSpecAutoscaling)(ptr) = AzureNodePoolSpecAutoscaling{}
			}
		} else {
			*(*AzureNodePoolSpecAutoscaling)(ptr) = AzureNodePoolSpecAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureNodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureNodePoolSpecAutoscaling)(ptr) = obj
		} else {
			*(*AzureNodePoolSpecAutoscaling)(ptr) = AzureNodePoolSpecAutoscaling{}
		}
	default:
		iter.ReportError("decode AzureNodePoolSpecAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureNodePoolSpecConfigCodec struct {
}

func (AzureNodePoolSpecConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureNodePoolSpecConfig)(ptr) == nil
}

func (AzureNodePoolSpecConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureNodePoolSpecConfig)(ptr)
	var objs []AzureNodePoolSpecConfig
	if obj != nil {
		objs = []AzureNodePoolSpecConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureNodePoolSpecConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureNodePoolSpecConfig)(ptr) = AzureNodePoolSpecConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureNodePoolSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureNodePoolSpecConfig)(ptr) = objs[0]
			} else {
				*(*AzureNodePoolSpecConfig)(ptr) = AzureNodePoolSpecConfig{}
			}
		} else {
			*(*AzureNodePoolSpecConfig)(ptr) = AzureNodePoolSpecConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureNodePoolSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureNodePoolSpecConfig)(ptr) = obj
		} else {
			*(*AzureNodePoolSpecConfig)(ptr) = AzureNodePoolSpecConfig{}
		}
	default:
		iter.ReportError("decode AzureNodePoolSpecConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureNodePoolSpecConfigRootVolumeCodec struct {
}

func (AzureNodePoolSpecConfigRootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureNodePoolSpecConfigRootVolume)(ptr) == nil
}

func (AzureNodePoolSpecConfigRootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureNodePoolSpecConfigRootVolume)(ptr)
	var objs []AzureNodePoolSpecConfigRootVolume
	if obj != nil {
		objs = []AzureNodePoolSpecConfigRootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigRootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureNodePoolSpecConfigRootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureNodePoolSpecConfigRootVolume)(ptr) = AzureNodePoolSpecConfigRootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureNodePoolSpecConfigRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureNodePoolSpecConfigRootVolume)(ptr) = objs[0]
			} else {
				*(*AzureNodePoolSpecConfigRootVolume)(ptr) = AzureNodePoolSpecConfigRootVolume{}
			}
		} else {
			*(*AzureNodePoolSpecConfigRootVolume)(ptr) = AzureNodePoolSpecConfigRootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureNodePoolSpecConfigRootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigRootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureNodePoolSpecConfigRootVolume)(ptr) = obj
		} else {
			*(*AzureNodePoolSpecConfigRootVolume)(ptr) = AzureNodePoolSpecConfigRootVolume{}
		}
	default:
		iter.ReportError("decode AzureNodePoolSpecConfigRootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureNodePoolSpecConfigSshConfigCodec struct {
}

func (AzureNodePoolSpecConfigSshConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureNodePoolSpecConfigSshConfig)(ptr) == nil
}

func (AzureNodePoolSpecConfigSshConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureNodePoolSpecConfigSshConfig)(ptr)
	var objs []AzureNodePoolSpecConfigSshConfig
	if obj != nil {
		objs = []AzureNodePoolSpecConfigSshConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigSshConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureNodePoolSpecConfigSshConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureNodePoolSpecConfigSshConfig)(ptr) = AzureNodePoolSpecConfigSshConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureNodePoolSpecConfigSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureNodePoolSpecConfigSshConfig)(ptr) = objs[0]
			} else {
				*(*AzureNodePoolSpecConfigSshConfig)(ptr) = AzureNodePoolSpecConfigSshConfig{}
			}
		} else {
			*(*AzureNodePoolSpecConfigSshConfig)(ptr) = AzureNodePoolSpecConfigSshConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureNodePoolSpecConfigSshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecConfigSshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureNodePoolSpecConfigSshConfig)(ptr) = obj
		} else {
			*(*AzureNodePoolSpecConfigSshConfig)(ptr) = AzureNodePoolSpecConfigSshConfig{}
		}
	default:
		iter.ReportError("decode AzureNodePoolSpecConfigSshConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzureNodePoolSpecMaxPodsConstraintCodec struct {
}

func (AzureNodePoolSpecMaxPodsConstraintCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzureNodePoolSpecMaxPodsConstraint)(ptr) == nil
}

func (AzureNodePoolSpecMaxPodsConstraintCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzureNodePoolSpecMaxPodsConstraint)(ptr)
	var objs []AzureNodePoolSpecMaxPodsConstraint
	if obj != nil {
		objs = []AzureNodePoolSpecMaxPodsConstraint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecMaxPodsConstraint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzureNodePoolSpecMaxPodsConstraintCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = AzureNodePoolSpecMaxPodsConstraint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzureNodePoolSpecMaxPodsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecMaxPodsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = objs[0]
			} else {
				*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = AzureNodePoolSpecMaxPodsConstraint{}
			}
		} else {
			*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = AzureNodePoolSpecMaxPodsConstraint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzureNodePoolSpecMaxPodsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzureNodePoolSpecMaxPodsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = obj
		} else {
			*(*AzureNodePoolSpecMaxPodsConstraint)(ptr) = AzureNodePoolSpecMaxPodsConstraint{}
		}
	default:
		iter.ReportError("decode AzureNodePoolSpecMaxPodsConstraint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigCodec struct {
}

func (ClusterSpecAddonsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfig)(ptr)
	var objs []ClusterSpecAddonsConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfig)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigCloudrunConfigCodec struct {
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigCloudrunConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigCloudrunConfig)(ptr)
	var objs []ClusterSpecAddonsConfigCloudrunConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfigCloudrunConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigCloudrunConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfigCloudrunConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigCloudrunConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec struct {
}

func (ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr)
	var objs []ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig)(ptr) = ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigGcpFilestoreCsiDriverConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec struct {
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) == nil
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr)
	var objs []ClusterSpecAddonsConfigHorizontalPodAutoscaling
	if obj != nil {
		objs = []ClusterSpecAddonsConfigHorizontalPodAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigHorizontalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
			}
		} else {
			*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfigHorizontalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigHorizontalPodAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigHttpLoadBalancingCodec struct {
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) == nil
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr)
	var objs []ClusterSpecAddonsConfigHttpLoadBalancing
	if obj != nil {
		objs = []ClusterSpecAddonsConfigHttpLoadBalancing{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigHttpLoadBalancing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
			}
		} else {
			*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfigHttpLoadBalancing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigHttpLoadBalancing", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigNetworkPolicyConfigCodec struct {
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr)
	var objs []ClusterSpecAddonsConfigNetworkPolicyConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfigNetworkPolicyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigNetworkPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAddonsConfigNetworkPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = obj
		} else {
			*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigNetworkPolicyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAuthenticatorGroupsConfigCodec struct {
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAuthenticatorGroupsConfig)(ptr) == nil
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAuthenticatorGroupsConfig)(ptr)
	var objs []ClusterSpecAuthenticatorGroupsConfig
	if obj != nil {
		objs = []ClusterSpecAuthenticatorGroupsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAuthenticatorGroupsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
			}
		} else {
			*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAuthenticatorGroupsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = obj
		} else {
			*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAuthenticatorGroupsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterAutoscalingCodec struct {
}

func (ClusterSpecClusterAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterAutoscaling)(ptr) == nil
}

func (ClusterSpecClusterAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterAutoscaling)(ptr)
	var objs []ClusterSpecClusterAutoscaling
	if obj != nil {
		objs = []ClusterSpecClusterAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
			}
		} else {
			*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterAutoscaling)(ptr) = obj
		} else {
			*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec struct {
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) == nil
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr)
	var objs []ClusterSpecClusterAutoscalingAutoProvisioningDefaults
	if obj != nil {
		objs = []ClusterSpecClusterAutoscalingAutoProvisioningDefaults{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterAutoscalingAutoProvisioningDefaults

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
			}
		} else {
			*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterAutoscalingAutoProvisioningDefaults

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = obj
		} else {
			*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterAutoscalingAutoProvisioningDefaults", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecConfidentialNodesCodec struct {
}

func (ClusterSpecConfidentialNodesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecConfidentialNodes)(ptr) == nil
}

func (ClusterSpecConfidentialNodesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecConfidentialNodes)(ptr)
	var objs []ClusterSpecConfidentialNodes
	if obj != nil {
		objs = []ClusterSpecConfidentialNodes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfidentialNodes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecConfidentialNodesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecConfidentialNodes)(ptr) = ClusterSpecConfidentialNodes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecConfidentialNodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfidentialNodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecConfidentialNodes)(ptr) = objs[0]
			} else {
				*(*ClusterSpecConfidentialNodes)(ptr) = ClusterSpecConfidentialNodes{}
			}
		} else {
			*(*ClusterSpecConfidentialNodes)(ptr) = ClusterSpecConfidentialNodes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecConfidentialNodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfidentialNodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecConfidentialNodes)(ptr) = obj
		} else {
			*(*ClusterSpecConfidentialNodes)(ptr) = ClusterSpecConfidentialNodes{}
		}
	default:
		iter.ReportError("decode ClusterSpecConfidentialNodes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecDatabaseEncryptionCodec struct {
}

func (ClusterSpecDatabaseEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecDatabaseEncryption)(ptr) == nil
}

func (ClusterSpecDatabaseEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecDatabaseEncryption)(ptr)
	var objs []ClusterSpecDatabaseEncryption
	if obj != nil {
		objs = []ClusterSpecDatabaseEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecDatabaseEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecDatabaseEncryption)(ptr) = objs[0]
			} else {
				*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
			}
		} else {
			*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecDatabaseEncryption)(ptr) = obj
		} else {
			*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
		}
	default:
		iter.ReportError("decode ClusterSpecDatabaseEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecDefaultSnatStatusCodec struct {
}

func (ClusterSpecDefaultSnatStatusCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecDefaultSnatStatus)(ptr) == nil
}

func (ClusterSpecDefaultSnatStatusCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecDefaultSnatStatus)(ptr)
	var objs []ClusterSpecDefaultSnatStatus
	if obj != nil {
		objs = []ClusterSpecDefaultSnatStatus{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecDefaultSnatStatusCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecDefaultSnatStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecDefaultSnatStatus)(ptr) = objs[0]
			} else {
				*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
			}
		} else {
			*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecDefaultSnatStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecDefaultSnatStatus)(ptr) = obj
		} else {
			*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
		}
	default:
		iter.ReportError("decode ClusterSpecDefaultSnatStatus", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecDnsConfigCodec struct {
}

func (ClusterSpecDnsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecDnsConfig)(ptr) == nil
}

func (ClusterSpecDnsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecDnsConfig)(ptr)
	var objs []ClusterSpecDnsConfig
	if obj != nil {
		objs = []ClusterSpecDnsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDnsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecDnsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecDnsConfig)(ptr) = ClusterSpecDnsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecDnsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDnsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecDnsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecDnsConfig)(ptr) = ClusterSpecDnsConfig{}
			}
		} else {
			*(*ClusterSpecDnsConfig)(ptr) = ClusterSpecDnsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecDnsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDnsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecDnsConfig)(ptr) = obj
		} else {
			*(*ClusterSpecDnsConfig)(ptr) = ClusterSpecDnsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecDnsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecIpAllocationPolicyCodec struct {
}

func (ClusterSpecIpAllocationPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecIpAllocationPolicy)(ptr) == nil
}

func (ClusterSpecIpAllocationPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecIpAllocationPolicy)(ptr)
	var objs []ClusterSpecIpAllocationPolicy
	if obj != nil {
		objs = []ClusterSpecIpAllocationPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecIpAllocationPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecIpAllocationPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecIpAllocationPolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
			}
		} else {
			*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecIpAllocationPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecIpAllocationPolicy)(ptr) = obj
		} else {
			*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecIpAllocationPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingConfigCodec struct {
}

func (ClusterSpecLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingConfig)(ptr) == nil
}

func (ClusterSpecLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingConfig)(ptr)
	var objs []ClusterSpecLoggingConfig
	if obj != nil {
		objs = []ClusterSpecLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingConfig)(ptr) = ClusterSpecLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingConfig)(ptr) = ClusterSpecLoggingConfig{}
			}
		} else {
			*(*ClusterSpecLoggingConfig)(ptr) = ClusterSpecLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecLoggingConfig)(ptr) = obj
		} else {
			*(*ClusterSpecLoggingConfig)(ptr) = ClusterSpecLoggingConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyCodec struct {
}

func (ClusterSpecMaintenancePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicy)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicy)(ptr)
	var objs []ClusterSpecMaintenancePolicy
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMaintenancePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMaintenancePolicy)(ptr) = obj
		} else {
			*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec struct {
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr)
	var objs []ClusterSpecMaintenancePolicyDailyMaintenanceWindow
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicyDailyMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicyDailyMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMaintenancePolicyDailyMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = obj
		} else {
			*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicyDailyMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyRecurringWindowCodec struct {
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicyRecurringWindow)(ptr)
	var objs []ClusterSpecMaintenancePolicyRecurringWindow
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicyRecurringWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicyRecurringWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMaintenancePolicyRecurringWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = obj
		} else {
			*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicyRecurringWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthCodec struct {
}

func (ClusterSpecMasterAuthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuth)(ptr) == nil
}

func (ClusterSpecMasterAuthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuth)(ptr)
	var objs []ClusterSpecMasterAuth
	if obj != nil {
		objs = []ClusterSpecMasterAuth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuth)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
			}
		} else {
			*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMasterAuth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMasterAuth)(ptr) = obj
		} else {
			*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthClientCertificateConfigCodec struct {
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuthClientCertificateConfig)(ptr) == nil
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuthClientCertificateConfig)(ptr)
	var objs []ClusterSpecMasterAuthClientCertificateConfig
	if obj != nil {
		objs = []ClusterSpecMasterAuthClientCertificateConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuthClientCertificateConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
			}
		} else {
			*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMasterAuthClientCertificateConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = obj
		} else {
			*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuthClientCertificateConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthorizedNetworksConfigCodec struct {
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) == nil
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuthorizedNetworksConfig)(ptr)
	var objs []ClusterSpecMasterAuthorizedNetworksConfig
	if obj != nil {
		objs = []ClusterSpecMasterAuthorizedNetworksConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuthorizedNetworksConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
			}
		} else {
			*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMasterAuthorizedNetworksConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = obj
		} else {
			*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuthorizedNetworksConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMonitoringConfigCodec struct {
}

func (ClusterSpecMonitoringConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMonitoringConfig)(ptr) == nil
}

func (ClusterSpecMonitoringConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMonitoringConfig)(ptr)
	var objs []ClusterSpecMonitoringConfig
	if obj != nil {
		objs = []ClusterSpecMonitoringConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMonitoringConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMonitoringConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMonitoringConfig)(ptr) = ClusterSpecMonitoringConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMonitoringConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMonitoringConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMonitoringConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMonitoringConfig)(ptr) = ClusterSpecMonitoringConfig{}
			}
		} else {
			*(*ClusterSpecMonitoringConfig)(ptr) = ClusterSpecMonitoringConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMonitoringConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMonitoringConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMonitoringConfig)(ptr) = obj
		} else {
			*(*ClusterSpecMonitoringConfig)(ptr) = ClusterSpecMonitoringConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecMonitoringConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNetworkPolicyCodec struct {
}

func (ClusterSpecNetworkPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNetworkPolicy)(ptr) == nil
}

func (ClusterSpecNetworkPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNetworkPolicy)(ptr)
	var objs []ClusterSpecNetworkPolicy
	if obj != nil {
		objs = []ClusterSpecNetworkPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNetworkPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNetworkPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNetworkPolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
			}
		} else {
			*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNetworkPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNetworkPolicy)(ptr) = obj
		} else {
			*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecNetworkPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigCodec struct {
}

func (ClusterSpecNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfig)(ptr)
	var objs []ClusterSpecNodeConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodeConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigGcfsConfigCodec struct {
}

func (ClusterSpecNodeConfigGcfsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfigGcfsConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigGcfsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfigGcfsConfig)(ptr)
	var objs []ClusterSpecNodeConfigGcfsConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfigGcfsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigGcfsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigGcfsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = ClusterSpecNodeConfigGcfsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = ClusterSpecNodeConfigGcfsConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = ClusterSpecNodeConfigGcfsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodeConfigGcfsConfig)(ptr) = ClusterSpecNodeConfigGcfsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfigGcfsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigShieldedInstanceConfigCodec struct {
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr)
	var objs []ClusterSpecNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigWorkloadMetadataConfigCodec struct {
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []ClusterSpecNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolAutoscalingCodec struct {
}

func (ClusterSpecNodePoolAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolAutoscaling)(ptr) == nil
}

func (ClusterSpecNodePoolAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolAutoscaling)(ptr)
	var objs []ClusterSpecNodePoolAutoscaling
	if obj != nil {
		objs = []ClusterSpecNodePoolAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
			}
		} else {
			*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolAutoscaling)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolManagementCodec struct {
}

func (ClusterSpecNodePoolManagementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolManagement)(ptr) == nil
}

func (ClusterSpecNodePoolManagementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolManagement)(ptr)
	var objs []ClusterSpecNodePoolManagement
	if obj != nil {
		objs = []ClusterSpecNodePoolManagement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolManagementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolManagement)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
			}
		} else {
			*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolManagement)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolManagement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolNodeConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigGcfsConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigGcfsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigGcfsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfigGcfsConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfigGcfsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigGcfsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigGcfsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = ClusterSpecNodePoolNodeConfigGcfsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = ClusterSpecNodePoolNodeConfigGcfsConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = ClusterSpecNodePoolNodeConfigGcfsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolNodeConfigGcfsConfig)(ptr) = ClusterSpecNodePoolNodeConfigGcfsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfigGcfsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolUpgradeSettingsCodec struct {
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolUpgradeSettings)(ptr) == nil
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolUpgradeSettings)(ptr)
	var objs []ClusterSpecNodePoolUpgradeSettings
	if obj != nil {
		objs = []ClusterSpecNodePoolUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
			}
		} else {
			*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = obj
		} else {
			*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolUpgradeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecPrivateClusterConfigCodec struct {
}

func (ClusterSpecPrivateClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecPrivateClusterConfig)(ptr) == nil
}

func (ClusterSpecPrivateClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecPrivateClusterConfig)(ptr)
	var objs []ClusterSpecPrivateClusterConfig
	if obj != nil {
		objs = []ClusterSpecPrivateClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecPrivateClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecPrivateClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecPrivateClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
			}
		} else {
			*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecPrivateClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecPrivateClusterConfig)(ptr) = obj
		} else {
			*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecPrivateClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec struct {
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) == nil
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr)
	var objs []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig
	if obj != nil {
		objs = []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
			}
		} else {
			*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = obj
		} else {
			*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReleaseChannelCodec struct {
}

func (ClusterSpecReleaseChannelCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReleaseChannel)(ptr) == nil
}

func (ClusterSpecReleaseChannelCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReleaseChannel)(ptr)
	var objs []ClusterSpecReleaseChannel
	if obj != nil {
		objs = []ClusterSpecReleaseChannel{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReleaseChannelCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReleaseChannel

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReleaseChannel)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
			}
		} else {
			*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecReleaseChannel

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecReleaseChannel)(ptr) = obj
		} else {
			*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
		}
	default:
		iter.ReportError("decode ClusterSpecReleaseChannel", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecResourceUsageExportConfigCodec struct {
}

func (ClusterSpecResourceUsageExportConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecResourceUsageExportConfig)(ptr) == nil
}

func (ClusterSpecResourceUsageExportConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecResourceUsageExportConfig)(ptr)
	var objs []ClusterSpecResourceUsageExportConfig
	if obj != nil {
		objs = []ClusterSpecResourceUsageExportConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecResourceUsageExportConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecResourceUsageExportConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecResourceUsageExportConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
			}
		} else {
			*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecResourceUsageExportConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecResourceUsageExportConfig)(ptr) = obj
		} else {
			*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecResourceUsageExportConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec struct {
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) == nil
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr)
	var objs []ClusterSpecResourceUsageExportConfigBigqueryDestination
	if obj != nil {
		objs = []ClusterSpecResourceUsageExportConfigBigqueryDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecResourceUsageExportConfigBigqueryDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = objs[0]
			} else {
				*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
			}
		} else {
			*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecResourceUsageExportConfigBigqueryDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = obj
		} else {
			*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
		}
	default:
		iter.ReportError("decode ClusterSpecResourceUsageExportConfigBigqueryDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecVerticalPodAutoscalingCodec struct {
}

func (ClusterSpecVerticalPodAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecVerticalPodAutoscaling)(ptr) == nil
}

func (ClusterSpecVerticalPodAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecVerticalPodAutoscaling)(ptr)
	var objs []ClusterSpecVerticalPodAutoscaling
	if obj != nil {
		objs = []ClusterSpecVerticalPodAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecVerticalPodAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecVerticalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecVerticalPodAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
			}
		} else {
			*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecVerticalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecVerticalPodAutoscaling)(ptr) = obj
		} else {
			*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecVerticalPodAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecWorkloadIdentityConfigCodec struct {
}

func (ClusterSpecWorkloadIdentityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecWorkloadIdentityConfig)(ptr) == nil
}

func (ClusterSpecWorkloadIdentityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecWorkloadIdentityConfig)(ptr)
	var objs []ClusterSpecWorkloadIdentityConfig
	if obj != nil {
		objs = []ClusterSpecWorkloadIdentityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecWorkloadIdentityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecWorkloadIdentityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecWorkloadIdentityConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
			}
		} else {
			*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecWorkloadIdentityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecWorkloadIdentityConfig)(ptr) = obj
		} else {
			*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecWorkloadIdentityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecAutoscalingCodec struct {
}

func (NodePoolSpecAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecAutoscaling)(ptr) == nil
}

func (NodePoolSpecAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecAutoscaling)(ptr)
	var objs []NodePoolSpecAutoscaling
	if obj != nil {
		objs = []NodePoolSpecAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecAutoscaling)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
			}
		} else {
			*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecAutoscaling)(ptr) = obj
		} else {
			*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
		}
	default:
		iter.ReportError("decode NodePoolSpecAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecManagementCodec struct {
}

func (NodePoolSpecManagementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecManagement)(ptr) == nil
}

func (NodePoolSpecManagementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecManagement)(ptr)
	var objs []NodePoolSpecManagement
	if obj != nil {
		objs = []NodePoolSpecManagement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecManagementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecManagement)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
			}
		} else {
			*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecManagement)(ptr) = obj
		} else {
			*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
		}
	default:
		iter.ReportError("decode NodePoolSpecManagement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigCodec struct {
}

func (NodePoolSpecNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfig)(ptr)
	var objs []NodePoolSpecNodeConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigGcfsConfigCodec struct {
}

func (NodePoolSpecNodeConfigGcfsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigGcfsConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigGcfsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigGcfsConfig)(ptr)
	var objs []NodePoolSpecNodeConfigGcfsConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfigGcfsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigGcfsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigGcfsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = NodePoolSpecNodeConfigGcfsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = NodePoolSpecNodeConfigGcfsConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = NodePoolSpecNodeConfigGcfsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeConfigGcfsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigGcfsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeConfigGcfsConfig)(ptr) = NodePoolSpecNodeConfigGcfsConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigGcfsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigShieldedInstanceConfigCodec struct {
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr)
	var objs []NodePoolSpecNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigWorkloadMetadataConfigCodec struct {
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []NodePoolSpecNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecUpgradeSettingsCodec struct {
}

func (NodePoolSpecUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecUpgradeSettings)(ptr) == nil
}

func (NodePoolSpecUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecUpgradeSettings)(ptr)
	var objs []NodePoolSpecUpgradeSettings
	if obj != nil {
		objs = []NodePoolSpecUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
			}
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecUpgradeSettings)(ptr) = obj
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	default:
		iter.ReportError("decode NodePoolSpecUpgradeSettings", "unexpected JSON type")
	}
}
