/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1()):                                                  AutoscalingPolicySpecBasicAlgorithmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1()):                                        AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1()):                                           AutoscalingPolicySpecSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1()):                                                    AutoscalingPolicySpecWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1()):                                                             ClusterSpecClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1()):                                            ClusterSpecClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1()):                                             ClusterSpecClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1()):                                             ClusterSpecClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}).Type1()):                       ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1()):                                                 ClusterSpecClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1()):                                       ClusterSpecClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1()):                                      ClusterSpecClusterConfigPreemptibleWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1()):                            ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1()):                                               ClusterSpecClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1()):                                 ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1()):                                               ClusterSpecClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1()):                                                 ClusterSpecClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1()):                                       ClusterSpecClusterConfigWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1()):                                                       ClusterIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1()):                                                        ClusterIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1()):                                                                  JobSpecHadoopConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1()):                                                     JobSpecHadoopConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1()):                                                                    JobSpecHiveConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1()):                                                                     JobSpecPigConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1()):                                                        JobSpecPigConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1()):                                                                     JobSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1()):                                                                 JobSpecPysparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1()):                                                    JobSpecPysparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1()):                                                                     JobSpecReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1()):                                                                    JobSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1()):                                                                   JobSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1()):                                                      JobSpecSparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1()):                                                                JobSpecSparksqlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1()):                                                   JobSpecSparksqlConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1()):                                                           JobIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1()):                                                            JobIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJob{}).Type1()):                                                    WorkflowTemplateSpecJobsHadoopJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJob{}).Type1()):                                                      WorkflowTemplateSpecJobsHiveJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJobQueryList{}).Type1()):                                             WorkflowTemplateSpecJobsHiveJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJob{}).Type1()):                                                       WorkflowTemplateSpecJobsPigJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobLoggingConfig{}).Type1()):                                          WorkflowTemplateSpecJobsPigJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobQueryList{}).Type1()):                                              WorkflowTemplateSpecJobsPigJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJob{}).Type1()):                                                    WorkflowTemplateSpecJobsPrestoJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobQueryList{}).Type1()):                                           WorkflowTemplateSpecJobsPrestoJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJob{}).Type1()):                                                   WorkflowTemplateSpecJobsPysparkJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}).Type1()):                                      WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsScheduling{}).Type1()):                                                   WorkflowTemplateSpecJobsSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJob{}).Type1()):                                                     WorkflowTemplateSpecJobsSparkJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJobLoggingConfig{}).Type1()):                                        WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJob{}).Type1()):                                                    WorkflowTemplateSpecJobsSparkRJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJob{}).Type1()):                                                  WorkflowTemplateSpecJobsSparkSQLJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}).Type1()):                                     WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobQueryList{}).Type1()):                                         WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidation{}).Type1()):                                             WorkflowTemplateSpecParametersValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationRegex{}).Type1()):                                        WorkflowTemplateSpecParametersValidationRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationValues{}).Type1()):                                       WorkflowTemplateSpecParametersValidationValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacement{}).Type1()):                                                        WorkflowTemplateSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementClusterSelector{}).Type1()):                                         WorkflowTemplateSpecPlacementClusterSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedCluster{}).Type1()):                                          WorkflowTemplateSpecPlacementManagedClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfig{}).Type1()):                                    WorkflowTemplateSpecPlacementManagedClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}).Type1()):                   WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}).Type1()):                    WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}).Type1()):                    WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}).Type1()):   WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}).Type1()): WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}).Type1()):                     WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}).Type1()):                        WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}).Type1()):              WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}).Type1()):               WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}).Type1()):     WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}).Type1()):        WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}).Type1()):                        WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}).Type1()):              WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1()):                                                  AutoscalingPolicySpecBasicAlgorithmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1()):                                        AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1()):                                           AutoscalingPolicySpecSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1()):                                                    AutoscalingPolicySpecWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1()):                                                             ClusterSpecClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1()):                                            ClusterSpecClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1()):                                             ClusterSpecClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1()):                                             ClusterSpecClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}).Type1()):                       ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1()):                                                 ClusterSpecClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1()):                                       ClusterSpecClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1()):                                      ClusterSpecClusterConfigPreemptibleWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1()):                            ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1()):                                               ClusterSpecClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1()):                                 ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1()):                                               ClusterSpecClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1()):                                                 ClusterSpecClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1()):                                       ClusterSpecClusterConfigWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1()):                                                       ClusterIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1()):                                                        ClusterIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1()):                                                                  JobSpecHadoopConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1()):                                                     JobSpecHadoopConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1()):                                                                    JobSpecHiveConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1()):                                                                     JobSpecPigConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1()):                                                        JobSpecPigConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1()):                                                                     JobSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1()):                                                                 JobSpecPysparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1()):                                                    JobSpecPysparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1()):                                                                     JobSpecReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1()):                                                                    JobSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1()):                                                                   JobSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1()):                                                      JobSpecSparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1()):                                                                JobSpecSparksqlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1()):                                                   JobSpecSparksqlConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1()):                                                           JobIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1()):                                                            JobIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJob{}).Type1()):                                                    WorkflowTemplateSpecJobsHadoopJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJob{}).Type1()):                                                      WorkflowTemplateSpecJobsHiveJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJobQueryList{}).Type1()):                                             WorkflowTemplateSpecJobsHiveJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJob{}).Type1()):                                                       WorkflowTemplateSpecJobsPigJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobLoggingConfig{}).Type1()):                                          WorkflowTemplateSpecJobsPigJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobQueryList{}).Type1()):                                              WorkflowTemplateSpecJobsPigJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJob{}).Type1()):                                                    WorkflowTemplateSpecJobsPrestoJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobQueryList{}).Type1()):                                           WorkflowTemplateSpecJobsPrestoJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJob{}).Type1()):                                                   WorkflowTemplateSpecJobsPysparkJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}).Type1()):                                      WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsScheduling{}).Type1()):                                                   WorkflowTemplateSpecJobsSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJob{}).Type1()):                                                     WorkflowTemplateSpecJobsSparkJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJobLoggingConfig{}).Type1()):                                        WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJob{}).Type1()):                                                    WorkflowTemplateSpecJobsSparkRJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}).Type1()):                                       WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJob{}).Type1()):                                                  WorkflowTemplateSpecJobsSparkSQLJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}).Type1()):                                     WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobQueryList{}).Type1()):                                         WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidation{}).Type1()):                                             WorkflowTemplateSpecParametersValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationRegex{}).Type1()):                                        WorkflowTemplateSpecParametersValidationRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationValues{}).Type1()):                                       WorkflowTemplateSpecParametersValidationValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacement{}).Type1()):                                                        WorkflowTemplateSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementClusterSelector{}).Type1()):                                         WorkflowTemplateSpecPlacementClusterSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedCluster{}).Type1()):                                          WorkflowTemplateSpecPlacementManagedClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfig{}).Type1()):                                    WorkflowTemplateSpecPlacementManagedClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}).Type1()):                   WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}).Type1()):                    WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}).Type1()):                    WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}).Type1()):   WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}).Type1()): WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}).Type1()):                     WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}).Type1()):                        WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}).Type1()):              WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}).Type1()):               WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}).Type1()):     WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}).Type1()):        WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}).Type1()):                      WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}).Type1()):                        WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}).Type1()):              WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecBasicAlgorithmCodec struct {
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecBasicAlgorithm)(ptr) == nil
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecBasicAlgorithm)(ptr)
	var objs []AutoscalingPolicySpecBasicAlgorithm
	if obj != nil {
		objs = []AutoscalingPolicySpecBasicAlgorithm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecBasicAlgorithm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
			}
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalingPolicySpecBasicAlgorithm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = obj
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecBasicAlgorithm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec struct {
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) == nil
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr)
	var objs []AutoscalingPolicySpecBasicAlgorithmYarnConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecBasicAlgorithmYarnConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecBasicAlgorithmYarnConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalingPolicySpecBasicAlgorithmYarnConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = obj
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecBasicAlgorithmYarnConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecSecondaryWorkerConfigCodec struct {
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) == nil
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr)
	var objs []AutoscalingPolicySpecSecondaryWorkerConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecSecondaryWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecSecondaryWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalingPolicySpecSecondaryWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = obj
		} else {
			*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecSecondaryWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecWorkerConfigCodec struct {
}

func (AutoscalingPolicySpecWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecWorkerConfig)(ptr) == nil
}

func (AutoscalingPolicySpecWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecWorkerConfig)(ptr)
	var objs []AutoscalingPolicySpecWorkerConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecWorkerConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoscalingPolicySpecWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoscalingPolicySpecWorkerConfig)(ptr) = obj
		} else {
			*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigCodec struct {
}

func (ClusterSpecClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfig)(ptr)
	var objs []ClusterSpecClusterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigAutoscalingConfigCodec struct {
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigAutoscalingConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigAutoscalingConfig)(ptr)
	var objs []ClusterSpecClusterConfigAutoscalingConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigAutoscalingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigAutoscalingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigAutoscalingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigAutoscalingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigEncryptionConfigCodec struct {
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigEncryptionConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigEncryptionConfig)(ptr)
	var objs []ClusterSpecClusterConfigEncryptionConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigEncryptionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigEncryptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigEncryptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigEncryptionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigGceClusterConfigCodec struct {
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigGceClusterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigGceClusterConfig)(ptr)
	var objs []ClusterSpecClusterConfigGceClusterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigGceClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigGceClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigGceClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigGceClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec struct {
}

func (ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr)
	var objs []ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigGceClusterConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigMasterConfigCodec struct {
}

func (ClusterSpecClusterConfigMasterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigMasterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigMasterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigMasterConfig)(ptr)
	var objs []ClusterSpecClusterConfigMasterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigMasterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigMasterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigMasterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigMasterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigMasterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigMasterConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigMasterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigMasterConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigMasterConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigMasterConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigMasterConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigMasterConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigMasterConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigPreemptibleWorkerConfigCodec struct {
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr)
	var objs []ClusterSpecClusterConfigPreemptibleWorkerConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigPreemptibleWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigPreemptibleWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigPreemptibleWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigPreemptibleWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSecurityConfigCodec struct {
}

func (ClusterSpecClusterConfigSecurityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSecurityConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSecurityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSecurityConfig)(ptr)
	var objs []ClusterSpecClusterConfigSecurityConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSecurityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSecurityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSecurityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigSecurityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSecurityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec struct {
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr)
	var objs []ClusterSpecClusterConfigSecurityConfigKerberosConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSecurityConfigKerberosConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSecurityConfigKerberosConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigSecurityConfigKerberosConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSecurityConfigKerberosConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSoftwareConfigCodec struct {
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSoftwareConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSoftwareConfig)(ptr)
	var objs []ClusterSpecClusterConfigSoftwareConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSoftwareConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSoftwareConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigSoftwareConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSoftwareConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigWorkerConfigCodec struct {
}

func (ClusterSpecClusterConfigWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigWorkerConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigWorkerConfig)(ptr)
	var objs []ClusterSpecClusterConfigWorkerConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigWorkerConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigWorkerConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecClusterConfigWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = obj
		} else {
			*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigWorkerConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterIamBindingSpecConditionCodec struct {
}

func (ClusterIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterIamBindingSpecCondition)(ptr) == nil
}

func (ClusterIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterIamBindingSpecCondition)(ptr)
	var objs []ClusterIamBindingSpecCondition
	if obj != nil {
		objs = []ClusterIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
			}
		} else {
			*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode ClusterIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterIamMemberSpecConditionCodec struct {
}

func (ClusterIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterIamMemberSpecCondition)(ptr) == nil
}

func (ClusterIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterIamMemberSpecCondition)(ptr)
	var objs []ClusterIamMemberSpecCondition
	if obj != nil {
		objs = []ClusterIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
			}
		} else {
			*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode ClusterIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHadoopConfigCodec struct {
}

func (JobSpecHadoopConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHadoopConfig)(ptr) == nil
}

func (JobSpecHadoopConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHadoopConfig)(ptr)
	var objs []JobSpecHadoopConfig
	if obj != nil {
		objs = []JobSpecHadoopConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHadoopConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHadoopConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHadoopConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
			}
		} else {
			*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecHadoopConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecHadoopConfig)(ptr) = obj
		} else {
			*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHadoopConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHadoopConfigLoggingConfigCodec struct {
}

func (JobSpecHadoopConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHadoopConfigLoggingConfig)(ptr) == nil
}

func (JobSpecHadoopConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHadoopConfigLoggingConfig)(ptr)
	var objs []JobSpecHadoopConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecHadoopConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHadoopConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHadoopConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHadoopConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecHadoopConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecHadoopConfigLoggingConfig)(ptr) = obj
		} else {
			*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHadoopConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHiveConfigCodec struct {
}

func (JobSpecHiveConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHiveConfig)(ptr) == nil
}

func (JobSpecHiveConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHiveConfig)(ptr)
	var objs []JobSpecHiveConfig
	if obj != nil {
		objs = []JobSpecHiveConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHiveConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHiveConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHiveConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
			}
		} else {
			*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecHiveConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecHiveConfig)(ptr) = obj
		} else {
			*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHiveConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPigConfigCodec struct {
}

func (JobSpecPigConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPigConfig)(ptr) == nil
}

func (JobSpecPigConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPigConfig)(ptr)
	var objs []JobSpecPigConfig
	if obj != nil {
		objs = []JobSpecPigConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPigConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPigConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPigConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
			}
		} else {
			*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecPigConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecPigConfig)(ptr) = obj
		} else {
			*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPigConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPigConfigLoggingConfigCodec struct {
}

func (JobSpecPigConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPigConfigLoggingConfig)(ptr) == nil
}

func (JobSpecPigConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPigConfigLoggingConfig)(ptr)
	var objs []JobSpecPigConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecPigConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPigConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPigConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPigConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecPigConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecPigConfigLoggingConfig)(ptr) = obj
		} else {
			*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPigConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPlacementCodec struct {
}

func (JobSpecPlacementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPlacement)(ptr) == nil
}

func (JobSpecPlacementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPlacement)(ptr)
	var objs []JobSpecPlacement
	if obj != nil {
		objs = []JobSpecPlacement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPlacementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPlacement)(ptr) = objs[0]
			} else {
				*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
			}
		} else {
			*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecPlacement)(ptr) = obj
		} else {
			*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
		}
	default:
		iter.ReportError("decode JobSpecPlacement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPysparkConfigCodec struct {
}

func (JobSpecPysparkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPysparkConfig)(ptr) == nil
}

func (JobSpecPysparkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPysparkConfig)(ptr)
	var objs []JobSpecPysparkConfig
	if obj != nil {
		objs = []JobSpecPysparkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPysparkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPysparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPysparkConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
			}
		} else {
			*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecPysparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecPysparkConfig)(ptr) = obj
		} else {
			*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPysparkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPysparkConfigLoggingConfigCodec struct {
}

func (JobSpecPysparkConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPysparkConfigLoggingConfig)(ptr) == nil
}

func (JobSpecPysparkConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPysparkConfigLoggingConfig)(ptr)
	var objs []JobSpecPysparkConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecPysparkConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPysparkConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPysparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPysparkConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecPysparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecPysparkConfigLoggingConfig)(ptr) = obj
		} else {
			*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPysparkConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecReferenceCodec struct {
}

func (JobSpecReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecReference)(ptr) == nil
}

func (JobSpecReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecReference)(ptr)
	var objs []JobSpecReference
	if obj != nil {
		objs = []JobSpecReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecReference)(ptr) = JobSpecReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecReference)(ptr) = objs[0]
			} else {
				*(*JobSpecReference)(ptr) = JobSpecReference{}
			}
		} else {
			*(*JobSpecReference)(ptr) = JobSpecReference{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecReference)(ptr) = obj
		} else {
			*(*JobSpecReference)(ptr) = JobSpecReference{}
		}
	default:
		iter.ReportError("decode JobSpecReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSchedulingCodec struct {
}

func (JobSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecScheduling)(ptr) == nil
}

func (JobSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecScheduling)(ptr)
	var objs []JobSpecScheduling
	if obj != nil {
		objs = []JobSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecScheduling)(ptr) = objs[0]
			} else {
				*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
			}
		} else {
			*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecScheduling)(ptr) = obj
		} else {
			*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
		}
	default:
		iter.ReportError("decode JobSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparkConfigCodec struct {
}

func (JobSpecSparkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparkConfig)(ptr) == nil
}

func (JobSpecSparkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparkConfig)(ptr)
	var objs []JobSpecSparkConfig
	if obj != nil {
		objs = []JobSpecSparkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparkConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
			}
		} else {
			*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecSparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecSparkConfig)(ptr) = obj
		} else {
			*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparkConfigLoggingConfigCodec struct {
}

func (JobSpecSparkConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparkConfigLoggingConfig)(ptr) == nil
}

func (JobSpecSparkConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparkConfigLoggingConfig)(ptr)
	var objs []JobSpecSparkConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecSparkConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparkConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparkConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecSparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecSparkConfigLoggingConfig)(ptr) = obj
		} else {
			*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparkConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparksqlConfigCodec struct {
}

func (JobSpecSparksqlConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparksqlConfig)(ptr) == nil
}

func (JobSpecSparksqlConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparksqlConfig)(ptr)
	var objs []JobSpecSparksqlConfig
	if obj != nil {
		objs = []JobSpecSparksqlConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparksqlConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparksqlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparksqlConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
			}
		} else {
			*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecSparksqlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecSparksqlConfig)(ptr) = obj
		} else {
			*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparksqlConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparksqlConfigLoggingConfigCodec struct {
}

func (JobSpecSparksqlConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparksqlConfigLoggingConfig)(ptr) == nil
}

func (JobSpecSparksqlConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparksqlConfigLoggingConfig)(ptr)
	var objs []JobSpecSparksqlConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecSparksqlConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparksqlConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparksqlConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecSparksqlConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = obj
		} else {
			*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparksqlConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobIamBindingSpecConditionCodec struct {
}

func (JobIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobIamBindingSpecCondition)(ptr) == nil
}

func (JobIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobIamBindingSpecCondition)(ptr)
	var objs []JobIamBindingSpecCondition
	if obj != nil {
		objs = []JobIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
			}
		} else {
			*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode JobIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobIamMemberSpecConditionCodec struct {
}

func (JobIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobIamMemberSpecCondition)(ptr) == nil
}

func (JobIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobIamMemberSpecCondition)(ptr)
	var objs []JobIamMemberSpecCondition
	if obj != nil {
		objs = []JobIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
			}
		} else {
			*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode JobIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsHadoopJobCodec struct {
}

func (WorkflowTemplateSpecJobsHadoopJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsHadoopJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsHadoopJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsHadoopJob)(ptr)
	var objs []WorkflowTemplateSpecJobsHadoopJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsHadoopJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsHadoopJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = WorkflowTemplateSpecJobsHadoopJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsHadoopJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = WorkflowTemplateSpecJobsHadoopJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = WorkflowTemplateSpecJobsHadoopJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsHadoopJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsHadoopJob)(ptr) = WorkflowTemplateSpecJobsHadoopJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsHadoopJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsHadoopJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsHadoopJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsHadoopJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsHadoopJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsHadoopJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsHadoopJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsHadoopJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsHadoopJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsHiveJobCodec struct {
}

func (WorkflowTemplateSpecJobsHiveJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsHiveJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsHiveJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsHiveJob)(ptr)
	var objs []WorkflowTemplateSpecJobsHiveJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsHiveJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsHiveJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = WorkflowTemplateSpecJobsHiveJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsHiveJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = WorkflowTemplateSpecJobsHiveJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = WorkflowTemplateSpecJobsHiveJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsHiveJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsHiveJob)(ptr) = WorkflowTemplateSpecJobsHiveJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsHiveJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsHiveJobQueryListCodec struct {
}

func (WorkflowTemplateSpecJobsHiveJobQueryListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) == nil
}

func (WorkflowTemplateSpecJobsHiveJobQueryListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr)
	var objs []WorkflowTemplateSpecJobsHiveJobQueryList
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsHiveJobQueryList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJobQueryList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsHiveJobQueryListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = WorkflowTemplateSpecJobsHiveJobQueryList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsHiveJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = WorkflowTemplateSpecJobsHiveJobQueryList{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = WorkflowTemplateSpecJobsHiveJobQueryList{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsHiveJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsHiveJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsHiveJobQueryList)(ptr) = WorkflowTemplateSpecJobsHiveJobQueryList{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsHiveJobQueryList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPigJobCodec struct {
}

func (WorkflowTemplateSpecJobsPigJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPigJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPigJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPigJob)(ptr)
	var objs []WorkflowTemplateSpecJobsPigJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPigJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPigJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPigJob)(ptr) = WorkflowTemplateSpecJobsPigJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPigJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPigJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPigJob)(ptr) = WorkflowTemplateSpecJobsPigJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPigJob)(ptr) = WorkflowTemplateSpecJobsPigJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPigJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPigJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPigJob)(ptr) = WorkflowTemplateSpecJobsPigJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPigJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPigJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsPigJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPigJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsPigJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPigJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPigJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPigJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPigJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPigJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPigJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPigJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPigJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPigJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPigJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPigJobQueryListCodec struct {
}

func (WorkflowTemplateSpecJobsPigJobQueryListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPigJobQueryListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPigJobQueryList)(ptr)
	var objs []WorkflowTemplateSpecJobsPigJobQueryList
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPigJobQueryList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobQueryList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPigJobQueryListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = WorkflowTemplateSpecJobsPigJobQueryList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPigJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = WorkflowTemplateSpecJobsPigJobQueryList{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = WorkflowTemplateSpecJobsPigJobQueryList{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPigJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPigJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPigJobQueryList)(ptr) = WorkflowTemplateSpecJobsPigJobQueryList{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPigJobQueryList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPrestoJobCodec struct {
}

func (WorkflowTemplateSpecJobsPrestoJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPrestoJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPrestoJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPrestoJob)(ptr)
	var objs []WorkflowTemplateSpecJobsPrestoJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPrestoJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPrestoJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = WorkflowTemplateSpecJobsPrestoJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPrestoJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = WorkflowTemplateSpecJobsPrestoJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = WorkflowTemplateSpecJobsPrestoJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPrestoJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJob)(ptr) = WorkflowTemplateSpecJobsPrestoJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPrestoJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsPrestoJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPrestoJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPrestoJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPrestoJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPrestoJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPrestoJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPrestoJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPrestoJobQueryListCodec struct {
}

func (WorkflowTemplateSpecJobsPrestoJobQueryListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPrestoJobQueryListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr)
	var objs []WorkflowTemplateSpecJobsPrestoJobQueryList
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPrestoJobQueryList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobQueryList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPrestoJobQueryListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = WorkflowTemplateSpecJobsPrestoJobQueryList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPrestoJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = WorkflowTemplateSpecJobsPrestoJobQueryList{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = WorkflowTemplateSpecJobsPrestoJobQueryList{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPrestoJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPrestoJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPrestoJobQueryList)(ptr) = WorkflowTemplateSpecJobsPrestoJobQueryList{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPrestoJobQueryList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPysparkJobCodec struct {
}

func (WorkflowTemplateSpecJobsPysparkJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPysparkJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPysparkJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPysparkJob)(ptr)
	var objs []WorkflowTemplateSpecJobsPysparkJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPysparkJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPysparkJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = WorkflowTemplateSpecJobsPysparkJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPysparkJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = WorkflowTemplateSpecJobsPysparkJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = WorkflowTemplateSpecJobsPysparkJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPysparkJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPysparkJob)(ptr) = WorkflowTemplateSpecJobsPysparkJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPysparkJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsPysparkJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsPysparkJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsPysparkJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsPysparkJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsPysparkJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsPysparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsPysparkJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsPysparkJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSchedulingCodec struct {
}

func (WorkflowTemplateSpecJobsSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsScheduling)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsScheduling)(ptr)
	var objs []WorkflowTemplateSpecJobsScheduling
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsScheduling)(ptr) = WorkflowTemplateSpecJobsScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsScheduling)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsScheduling)(ptr) = WorkflowTemplateSpecJobsScheduling{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsScheduling)(ptr) = WorkflowTemplateSpecJobsScheduling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsScheduling)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsScheduling)(ptr) = WorkflowTemplateSpecJobsScheduling{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkJobCodec struct {
}

func (WorkflowTemplateSpecJobsSparkJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkJob)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = WorkflowTemplateSpecJobsSparkJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = WorkflowTemplateSpecJobsSparkJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = WorkflowTemplateSpecJobsSparkJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkJob)(ptr) = WorkflowTemplateSpecJobsSparkJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkRJobCodec struct {
}

func (WorkflowTemplateSpecJobsSparkRJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkRJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkRJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkRJob)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkRJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkRJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkRJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = WorkflowTemplateSpecJobsSparkRJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkRJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = WorkflowTemplateSpecJobsSparkRJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = WorkflowTemplateSpecJobsSparkRJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkRJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkRJob)(ptr) = WorkflowTemplateSpecJobsSparkRJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkRJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkRJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkRJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkRJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkRJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkRJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkRJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkRJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkRJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkSQLJobCodec struct {
}

func (WorkflowTemplateSpecJobsSparkSQLJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkSQLJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkSQLJob)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkSQLJob
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkSQLJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkSQLJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = WorkflowTemplateSpecJobsSparkSQLJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkSQLJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = WorkflowTemplateSpecJobsSparkSQLJob{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = WorkflowTemplateSpecJobsSparkSQLJob{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkSQLJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJob)(ptr) = WorkflowTemplateSpecJobsSparkSQLJob{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkSQLJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec struct {
}

func (WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkSQLJobLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkSQLJobLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec struct {
}

func (WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) == nil
}

func (WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr)
	var objs []WorkflowTemplateSpecJobsSparkSQLJobQueryList
	if obj != nil {
		objs = []WorkflowTemplateSpecJobsSparkSQLJobQueryList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobQueryList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecJobsSparkSQLJobQueryListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobQueryList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecJobsSparkSQLJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobQueryList{}
			}
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobQueryList{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecJobsSparkSQLJobQueryList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecJobsSparkSQLJobQueryList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecJobsSparkSQLJobQueryList)(ptr) = WorkflowTemplateSpecJobsSparkSQLJobQueryList{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecJobsSparkSQLJobQueryList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecParametersValidationCodec struct {
}

func (WorkflowTemplateSpecParametersValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecParametersValidation)(ptr) == nil
}

func (WorkflowTemplateSpecParametersValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecParametersValidation)(ptr)
	var objs []WorkflowTemplateSpecParametersValidation
	if obj != nil {
		objs = []WorkflowTemplateSpecParametersValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecParametersValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecParametersValidation)(ptr) = WorkflowTemplateSpecParametersValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecParametersValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecParametersValidation)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecParametersValidation)(ptr) = WorkflowTemplateSpecParametersValidation{}
			}
		} else {
			*(*WorkflowTemplateSpecParametersValidation)(ptr) = WorkflowTemplateSpecParametersValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecParametersValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecParametersValidation)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecParametersValidation)(ptr) = WorkflowTemplateSpecParametersValidation{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecParametersValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecParametersValidationRegexCodec struct {
}

func (WorkflowTemplateSpecParametersValidationRegexCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecParametersValidationRegex)(ptr) == nil
}

func (WorkflowTemplateSpecParametersValidationRegexCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecParametersValidationRegex)(ptr)
	var objs []WorkflowTemplateSpecParametersValidationRegex
	if obj != nil {
		objs = []WorkflowTemplateSpecParametersValidationRegex{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationRegex{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecParametersValidationRegexCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = WorkflowTemplateSpecParametersValidationRegex{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecParametersValidationRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = WorkflowTemplateSpecParametersValidationRegex{}
			}
		} else {
			*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = WorkflowTemplateSpecParametersValidationRegex{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecParametersValidationRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecParametersValidationRegex)(ptr) = WorkflowTemplateSpecParametersValidationRegex{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecParametersValidationRegex", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecParametersValidationValuesCodec struct {
}

func (WorkflowTemplateSpecParametersValidationValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecParametersValidationValues)(ptr) == nil
}

func (WorkflowTemplateSpecParametersValidationValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecParametersValidationValues)(ptr)
	var objs []WorkflowTemplateSpecParametersValidationValues
	if obj != nil {
		objs = []WorkflowTemplateSpecParametersValidationValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecParametersValidationValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = WorkflowTemplateSpecParametersValidationValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecParametersValidationValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = WorkflowTemplateSpecParametersValidationValues{}
			}
		} else {
			*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = WorkflowTemplateSpecParametersValidationValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecParametersValidationValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecParametersValidationValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecParametersValidationValues)(ptr) = WorkflowTemplateSpecParametersValidationValues{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecParametersValidationValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementCodec struct {
}

func (WorkflowTemplateSpecPlacementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacement)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacement)(ptr)
	var objs []WorkflowTemplateSpecPlacement
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacement)(ptr) = WorkflowTemplateSpecPlacement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacement)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacement)(ptr) = WorkflowTemplateSpecPlacement{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacement)(ptr) = WorkflowTemplateSpecPlacement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacement)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacement)(ptr) = WorkflowTemplateSpecPlacement{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementClusterSelectorCodec struct {
}

func (WorkflowTemplateSpecPlacementClusterSelectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementClusterSelector)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementClusterSelectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementClusterSelector)(ptr)
	var objs []WorkflowTemplateSpecPlacementClusterSelector
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementClusterSelector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementClusterSelector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementClusterSelectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = WorkflowTemplateSpecPlacementClusterSelector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementClusterSelector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementClusterSelector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = WorkflowTemplateSpecPlacementClusterSelector{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = WorkflowTemplateSpecPlacementClusterSelector{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementClusterSelector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementClusterSelector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementClusterSelector)(ptr) = WorkflowTemplateSpecPlacementClusterSelector{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementClusterSelector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedCluster)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedCluster)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedCluster
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedCluster{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedCluster{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = WorkflowTemplateSpecPlacementManagedCluster{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = WorkflowTemplateSpecPlacementManagedCluster{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = WorkflowTemplateSpecPlacementManagedCluster{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedCluster)(ptr) = WorkflowTemplateSpecPlacementManagedCluster{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedCluster", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigAutoscalingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigEncryptionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigEndpointConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigGceClusterConfigReservationAffinity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigLifecycleConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigMasterConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigSecurityConfigKerberosConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigSoftwareConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec struct {
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) == nil
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr)
	var objs []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig
	if obj != nil {
		objs = []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}
			}
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = obj
		} else {
			*(*WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig)(ptr) = WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode WorkflowTemplateSpecPlacementManagedClusterConfigWorkerConfigDiskConfig", "unexpected JSON type")
	}
}
