/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ConfigOsPolicyAssignment struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConfigOsPolicyAssignmentSpec   `json:"spec,omitempty"`
	Status            ConfigOsPolicyAssignmentStatus `json:"status,omitempty"`
}

type ConfigOsPolicyAssignmentSpecInstanceFilterExclusionLabels struct {
	// Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
}

type ConfigOsPolicyAssignmentSpecInstanceFilterInclusionLabels struct {
	// Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
}

type ConfigOsPolicyAssignmentSpecInstanceFilterInventories struct {
	// Required. The OS short name
	OsShortName *string `json:"osShortName" tf:"os_short_name"`
	// The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of `7`, specify the following value for this field `7.*` An empty string matches all OS versions.
	// +optional
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version"`
}

type ConfigOsPolicyAssignmentSpecInstanceFilter struct {
	// Target all VMs in the project. If true, no other criteria is permitted.
	// +optional
	All *bool `json:"all,omitempty" tf:"all"`
	// List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM.
	// +optional
	ExclusionLabels []ConfigOsPolicyAssignmentSpecInstanceFilterExclusionLabels `json:"exclusionLabels,omitempty" tf:"exclusion_labels"`
	// List of label sets used for VM inclusion. If the list has more than one `LabelSet`, the VM is included if any of the label sets are applicable for the VM.
	// +optional
	InclusionLabels []ConfigOsPolicyAssignmentSpecInstanceFilterInclusionLabels `json:"inclusionLabels,omitempty" tf:"inclusion_labels"`
	// List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories.
	// +optional
	Inventories []ConfigOsPolicyAssignmentSpecInstanceFilterInventories `json:"inventories,omitempty" tf:"inventories"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsInventoryFilters struct {
	// Required. The OS short name
	OsShortName *string `json:"osShortName" tf:"os_short_name"`
	// The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of `7`, specify the following value for this field `7.*` An empty string matches all OS versions.
	// +optional
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFileGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFileRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFile struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFileGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFileRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforce struct {
	// Optional arguments to pass to the source during execution.
	// +optional
	Args []string `json:"args,omitempty" tf:"args"`
	// A remote or local file.
	// +optional
	File *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforceFile `json:"file,omitempty" tf:"file"`
	// Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL
	Interpreter *string `json:"interpreter" tf:"interpreter"`
	// Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
	// +optional
	OutputFilePath *string `json:"outputFilePath,omitempty" tf:"output_file_path"`
	// An inline script. The size of the script is limited to 1024 characters.
	// +optional
	Script *string `json:"script,omitempty" tf:"script"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFileGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFileRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFile struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFileGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFileRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidate struct {
	// Optional arguments to pass to the source during execution.
	// +optional
	Args []string `json:"args,omitempty" tf:"args"`
	// A remote or local file.
	// +optional
	File *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidateFile `json:"file,omitempty" tf:"file"`
	// Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL
	Interpreter *string `json:"interpreter" tf:"interpreter"`
	// Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
	// +optional
	OutputFilePath *string `json:"outputFilePath,omitempty" tf:"output_file_path"`
	// An inline script. The size of the script is limited to 1024 characters.
	// +optional
	Script *string `json:"script,omitempty" tf:"script"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExec struct {
	// What to run to bring this resource into the desired state. An exit code of 100 indicates "success", any other exit code indicates a failure running enforce.
	// +optional
	Enforce *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecEnforce `json:"enforce,omitempty" tf:"enforce"`
	// Required. What to run to validate this resource is in the desired state. An exit code of 100 indicates "in desired state", and exit code of 101 indicates "not in desired state". Any other exit code indicates a failure running validate.
	Validate *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExecValidate `json:"validate" tf:"validate"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFileGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFileRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFile struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFileGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFileRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFile struct {
	// A a file with this content. The size of the content is limited to 1024 characters.
	// +optional
	Content *string `json:"content,omitempty" tf:"content"`
	// A remote or local source.
	// +optional
	File *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFileFile `json:"file,omitempty" tf:"file"`
	// Required. The absolute path of the file within the VM.
	Path *string `json:"path" tf:"path"`
	// Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4
	// +optional
	Permissions *string `json:"permissions,omitempty" tf:"permissions"`
	// Required. Desired state of the file. Possible values: OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED, COMPLIANT, NON_COMPLIANT, UNKNOWN, NO_OS_POLICIES_APPLICABLE
	State *string `json:"state" tf:"state"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgApt struct {
	// Required. Package name.
	Name *string `json:"name" tf:"name"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSourceGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSourceRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSource struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSourceGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSourceRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDeb struct {
	// Whether dependencies should also be installed. - install when false: `dpkg -i package` - install when true: `apt-get update && apt-get -y install package.deb`
	// +optional
	PullDeps *bool `json:"pullDeps,omitempty" tf:"pull_deps"`
	// Required. A deb package.
	Source *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDebSource `json:"source" tf:"source"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgGooget struct {
	// Required. Package name.
	Name *string `json:"name" tf:"name"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSource struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsi struct {
	// Additional properties to use during installation. This should be in the format of Property=Setting. Appended to the defaults of `ACTION=INSTALL REBOOT=ReallySuppress`.
	// +optional
	Properties []string `json:"properties,omitempty" tf:"properties"`
	// Required. The MSI package.
	Source *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsiSource `json:"source" tf:"source"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs struct {
	// Required. Bucket of the Cloud Storage object.
	Bucket *string `json:"bucket" tf:"bucket"`
	// Generation number of the Cloud Storage object.
	// +optional
	Generation *int64 `json:"generation,omitempty" tf:"generation"`
	// Required. Name of the Cloud Storage object.
	Object *string `json:"object" tf:"object"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote struct {
	// SHA256 checksum of the remote file.
	// +optional
	Sha256Checksum *string `json:"sha256Checksum,omitempty" tf:"sha256_checksum"`
	// Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSource struct {
	// Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
	// +optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure"`
	// A Cloud Storage object.
	// +optional
	Gcs *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs `json:"gcs,omitempty" tf:"gcs"`
	// A local path within the VM to use.
	// +optional
	LocalPath *string `json:"localPath,omitempty" tf:"local_path"`
	// A generic remote file.
	// +optional
	Remote *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote `json:"remote,omitempty" tf:"remote"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpm struct {
	// Whether dependencies should also be installed. - install when false: `rpm --upgrade --replacepkgs package.rpm` - install when true: `yum -y install package.rpm` or `zypper -y install package.rpm`
	// +optional
	PullDeps *bool `json:"pullDeps,omitempty" tf:"pull_deps"`
	// Required. An rpm package.
	Source *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpmSource `json:"source" tf:"source"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgYum struct {
	// Required. Package name.
	Name *string `json:"name" tf:"name"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgZypper struct {
	// Required. Package name.
	Name *string `json:"name" tf:"name"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkg struct {
	// A package managed by Apt.
	// +optional
	Apt *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgApt `json:"apt,omitempty" tf:"apt"`
	// A deb package file.
	// +optional
	Deb *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgDeb `json:"deb,omitempty" tf:"deb"`
	// Required. The desired state the agent should maintain for this package. Possible values: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED
	DesiredState *string `json:"desiredState" tf:"desired_state"`
	// A package managed by GooGet.
	// +optional
	Googet *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgGooget `json:"googet,omitempty" tf:"googet"`
	// An MSI package.
	// +optional
	Msi *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgMsi `json:"msi,omitempty" tf:"msi"`
	// An rpm package file.
	// +optional
	Rpm *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgRpm `json:"rpm,omitempty" tf:"rpm"`
	// A package managed by YUM.
	// +optional
	Yum *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgYum `json:"yum,omitempty" tf:"yum"`
	// A package managed by Zypper.
	// +optional
	Zypper *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkgZypper `json:"zypper,omitempty" tf:"zypper"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryApt struct {
	// Required. Type of archive files in this repository. Possible values: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC
	ArchiveType *string `json:"archiveType" tf:"archive_type"`
	// Required. List of components for this repository. Must contain at least one item.
	Components []string `json:"components" tf:"components"`
	// Required. Distribution of this repository.
	Distribution *string `json:"distribution" tf:"distribution"`
	// URI of the key file for this repository. The agent maintains a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
	// +optional
	GpgKey *string `json:"gpgKey,omitempty" tf:"gpg_key"`
	// Required. URI for this repository.
	Uri *string `json:"uri" tf:"uri"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryGoo struct {
	// Required. The name of the repository.
	Name *string `json:"name" tf:"name"`
	// Required. The url of the repository.
	Url *string `json:"url" tf:"url"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryYum struct {
	// Required. The location of the repository directory.
	BaseURL *string `json:"baseURL" tf:"base_url"`
	// The display name of the repository.
	// +optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name"`
	// URIs of GPG keys.
	// +optional
	GpgKeys []string `json:"gpgKeys,omitempty" tf:"gpg_keys"`
	// Required. A one word, unique name for this repository. This is the `repo id` in the yum config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for resource conflicts.
	ID *string `json:"ID" tf:"id"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryZypper struct {
	// Required. The location of the repository directory.
	BaseURL *string `json:"baseURL" tf:"base_url"`
	// The display name of the repository.
	// +optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name"`
	// URIs of GPG keys.
	// +optional
	GpgKeys []string `json:"gpgKeys,omitempty" tf:"gpg_keys"`
	// Required. A one word, unique name for this repository. This is the `repo id` in the zypper config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
	ID *string `json:"ID" tf:"id"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepository struct {
	// An Apt Repository.
	// +optional
	Apt *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryApt `json:"apt,omitempty" tf:"apt"`
	// A Goo Repository.
	// +optional
	Goo *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryGoo `json:"goo,omitempty" tf:"goo"`
	// A Yum Repository.
	// +optional
	Yum *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryYum `json:"yum,omitempty" tf:"yum"`
	// A Zypper Repository.
	// +optional
	Zypper *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepositoryZypper `json:"zypper,omitempty" tf:"zypper"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResources struct {
	// Exec resource
	// +optional
	Exec *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesExec `json:"exec,omitempty" tf:"exec"`
	// File resource
	// +optional
	File *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesFile `json:"file,omitempty" tf:"file"`
	// Required. The id of the resource with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the OS policy.
	ID *string `json:"ID" tf:"id"`
	// Package resource
	// +optional
	Pkg *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesPkg `json:"pkg,omitempty" tf:"pkg"`
	// Package repository resource
	// +optional
	Repository *ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResourcesRepository `json:"repository,omitempty" tf:"repository"`
}

type ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroups struct {
	// List of inventory filters for the resource group. The resources in this resource group are applied to the target VM if it satisfies at least one of the following inventory filters. For example, to apply this resource group to VMs running either `RHEL` or `CentOS` operating systems, specify 2 items for the list with following values: inventory_filters[0].os_short_name='rhel' and inventory_filters[1].os_short_name='centos' If the list is empty, this resource group will be applied to the target VM unconditionally.
	// +optional
	InventoryFilters []ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsInventoryFilters `json:"inventoryFilters,omitempty" tf:"inventory_filters"`
	// Required. List of resources configured for this resource group. The resources are executed in the exact order specified here.
	Resources []ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroupsResources `json:"resources" tf:"resources"`
}

type ConfigOsPolicyAssignmentSpecOsPolicies struct {
	// This flag determines the OS policy compliance status when none of the resource groups within the policy are applicable for a VM. Set this value to `true` if the policy needs to be reported as compliant even if the policy has nothing to validate or enforce.
	// +optional
	AllowNoResourceGroupMatch *bool `json:"allowNoResourceGroupMatch,omitempty" tf:"allow_no_resource_group_match"`
	// Policy description. Length of the description is limited to 1024 characters.
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// Required. The id of the OS policy with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the assignment.
	ID *string `json:"ID" tf:"id"`
	// Required. Policy mode Possible values: MODE_UNSPECIFIED, VALIDATION, ENFORCEMENT
	Mode *string `json:"mode" tf:"mode"`
	// Required. List of resource groups for the policy. For a particular VM, resource groups are evaluated in the order specified and the first resource group that is applicable is selected and the rest are ignored. If none of the resource groups are applicable for a VM, the VM is considered to be non-compliant w.r.t this policy. This behavior can be toggled by the flag `allow_no_resource_group_match`
	ResourceGroups []ConfigOsPolicyAssignmentSpecOsPoliciesResourceGroups `json:"resourceGroups" tf:"resource_groups"`
}

type ConfigOsPolicyAssignmentSpecRolloutDisruptionBudget struct {
	// Specifies a fixed value.
	// +optional
	Fixed *int64 `json:"fixed,omitempty" tf:"fixed"`
	// Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
	// +optional
	Percent *int64 `json:"percent,omitempty" tf:"percent"`
}

type ConfigOsPolicyAssignmentSpecRollout struct {
	// Required. The maximum number (or percentage) of VMs per zone to disrupt at any given moment.
	DisruptionBudget *ConfigOsPolicyAssignmentSpecRolloutDisruptionBudget `json:"disruptionBudget" tf:"disruption_budget"`
	// Required. This determines the minimum duration of time to wait after the configuration changes are applied through the current rollout. A VM continues to count towards the `disruption_budget` at least until this duration of time has passed after configuration changes are applied.
	MinWaitDuration *string `json:"minWaitDuration" tf:"min_wait_duration"`
}

type ConfigOsPolicyAssignmentSpec struct {
	State *ConfigOsPolicyAssignmentSpecResource `json:"state,omitempty" tf:"-"`

	Resource ConfigOsPolicyAssignmentSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ConfigOsPolicyAssignmentSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Output only. Indicates that this revision has been successfully rolled out in this zone and new VMs will be assigned OS policies from this revision. For a given OS policy assignment, there is only one revision with a value of `true` for this field.
	// +optional
	Baseline *bool `json:"baseline,omitempty" tf:"baseline"`
	// Output only. Indicates that this revision deletes the OS policy assignment.
	// +optional
	Deleted *bool `json:"deleted,omitempty" tf:"deleted"`
	// OS policy assignment description. Length of the description is limited to 1024 characters.
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// The etag for this OS policy assignment. If this is provided on update, it must match the server's etag.
	// +optional
	Etag *string `json:"etag,omitempty" tf:"etag"`
	// Required. Filter to select VMs.
	InstanceFilter *ConfigOsPolicyAssignmentSpecInstanceFilter `json:"instanceFilter" tf:"instance_filter"`
	// The location for the resource
	Location *string `json:"location" tf:"location"`
	// Resource name.
	Name *string `json:"name" tf:"name"`
	// Required. List of OS policies to be applied to the VMs.
	OsPolicies []ConfigOsPolicyAssignmentSpecOsPolicies `json:"osPolicies" tf:"os_policies"`
	// The project for the resource
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
	// Output only. Indicates that reconciliation is in progress for the revision. This value is `true` when the `rollout_state` is one of: * IN_PROGRESS * CANCELLING
	// +optional
	Reconciling *bool `json:"reconciling,omitempty" tf:"reconciling"`
	// Output only. The timestamp that the revision was created.
	// +optional
	RevisionCreateTime *string `json:"revisionCreateTime,omitempty" tf:"revision_create_time"`
	// Output only. The assignment revision ID A new revision is committed whenever a rollout is triggered for a OS policy assignment
	// +optional
	RevisionID *string `json:"revisionID,omitempty" tf:"revision_id"`
	// Required. Rollout to deploy the OS policy assignment. A rollout is triggered in the following situations: 1) OSPolicyAssignment is created. 2) OSPolicyAssignment is updated and the update contains changes to one of the following fields: - instance_filter - os_policies 3) OSPolicyAssignment is deleted.
	Rollout *ConfigOsPolicyAssignmentSpecRollout `json:"rollout" tf:"rollout"`
	// Output only. OS policy assignment rollout state Possible values: ROLLOUT_STATE_UNSPECIFIED, IN_PROGRESS, CANCELLING, CANCELLED, SUCCEEDED
	// +optional
	RolloutState *string `json:"rolloutState,omitempty" tf:"rollout_state"`
	// Output only. Server generated unique id for the OS policy assignment resource.
	// +optional
	Uid *string `json:"uid,omitempty" tf:"uid"`
}

type ConfigOsPolicyAssignmentStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ConfigOsPolicyAssignmentList is a list of ConfigOsPolicyAssignments
type ConfigOsPolicyAssignmentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ConfigOsPolicyAssignment CRD objects
	Items []ConfigOsPolicyAssignment `json:"items,omitempty"`
}
