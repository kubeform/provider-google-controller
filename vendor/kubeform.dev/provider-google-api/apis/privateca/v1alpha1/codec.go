/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicy{}).Type1()):                                             CaPoolSpecIssuancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedIssuanceModes{}).Type1()):                         CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}).Type1()):                 CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}).Type1()):                           CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValues{}).Type1()):                               CaPoolSpecIssuancePolicyBaselineValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}).Type1()):   CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}).Type1()):                      CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}).Type1()):                       CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}).Type1()):           CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}).Type1()):       CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraints{}).Type1()):                          CaPoolSpecIssuancePolicyIdentityConstraintsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}).Type1()):             CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecPublishingOptions{}).Type1()):                                          CaPoolSpecPublishingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamBindingSpecCondition{}).Type1()):                                        CaPoolIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamMemberSpecCondition{}).Type1()):                                         CaPoolIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfig{}).Type1()):                                                CertificateSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigPublicKey{}).Type1()):                                       CertificateSpecConfigPublicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfig{}).Type1()):                                   CertificateSpecConfigSubjectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubject{}).Type1()):                            CertificateSpecConfigSubjectConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubjectAltName{}).Type1()):                     CertificateSpecConfigSubjectConfigSubjectAltNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509Config{}).Type1()):                                      CertificateSpecConfigX509ConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1()):          CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigCaOptions{}).Type1()):                             CertificateSpecConfigX509ConfigCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsage{}).Type1()):                              CertificateSpecConfigX509ConfigKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1()):                  CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1()):              CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfig{}).Type1()):                                       CertificateAuthoritySpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfig{}).Type1()):                          CertificateAuthoritySpecConfigSubjectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubject{}).Type1()):                   CertificateAuthoritySpecConfigSubjectConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}).Type1()):            CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509Config{}).Type1()):                             CertificateAuthoritySpecConfigX509ConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1()): CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigCaOptions{}).Type1()):                    CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsage{}).Type1()):                     CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1()):         CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1()):     CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecKeySpec{}).Type1()):                                      CertificateAuthoritySpecKeySpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraints{}).Type1()):                           CertificateTemplateSpecIdentityConstraintsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraintsCelExpression{}).Type1()):              CertificateTemplateSpecIdentityConstraintsCelExpressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPassthroughExtensions{}).Type1()):                         CertificateTemplateSpecPassthroughExtensionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValues{}).Type1()):                              CertificateTemplateSpecPredefinedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}).Type1()):  CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesCaOptions{}).Type1()):                     CertificateTemplateSpecPredefinedValuesCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsage{}).Type1()):                      CertificateTemplateSpecPredefinedValuesKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}).Type1()):          CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}).Type1()):      CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicy{}).Type1()):                                             CaPoolSpecIssuancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedIssuanceModes{}).Type1()):                         CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}).Type1()):                 CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}).Type1()):                           CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValues{}).Type1()):                               CaPoolSpecIssuancePolicyBaselineValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}).Type1()):   CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}).Type1()):                      CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}).Type1()):                       CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}).Type1()):           CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}).Type1()):       CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraints{}).Type1()):                          CaPoolSpecIssuancePolicyIdentityConstraintsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}).Type1()):             CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecPublishingOptions{}).Type1()):                                          CaPoolSpecPublishingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamBindingSpecCondition{}).Type1()):                                        CaPoolIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamMemberSpecCondition{}).Type1()):                                         CaPoolIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfig{}).Type1()):                                                CertificateSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigPublicKey{}).Type1()):                                       CertificateSpecConfigPublicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfig{}).Type1()):                                   CertificateSpecConfigSubjectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubject{}).Type1()):                            CertificateSpecConfigSubjectConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubjectAltName{}).Type1()):                     CertificateSpecConfigSubjectConfigSubjectAltNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509Config{}).Type1()):                                      CertificateSpecConfigX509ConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1()):          CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigCaOptions{}).Type1()):                             CertificateSpecConfigX509ConfigCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsage{}).Type1()):                              CertificateSpecConfigX509ConfigKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1()):                  CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1()):              CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfig{}).Type1()):                                       CertificateAuthoritySpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfig{}).Type1()):                          CertificateAuthoritySpecConfigSubjectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubject{}).Type1()):                   CertificateAuthoritySpecConfigSubjectConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}).Type1()):            CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509Config{}).Type1()):                             CertificateAuthoritySpecConfigX509ConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1()): CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigCaOptions{}).Type1()):                    CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsage{}).Type1()):                     CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1()):         CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1()):     CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecKeySpec{}).Type1()):                                      CertificateAuthoritySpecKeySpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraints{}).Type1()):                           CertificateTemplateSpecIdentityConstraintsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraintsCelExpression{}).Type1()):              CertificateTemplateSpecIdentityConstraintsCelExpressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPassthroughExtensions{}).Type1()):                         CertificateTemplateSpecPassthroughExtensionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValues{}).Type1()):                              CertificateTemplateSpecPredefinedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}).Type1()):  CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesCaOptions{}).Type1()):                     CertificateTemplateSpecPredefinedValuesCaOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsage{}).Type1()):                      CertificateTemplateSpecPredefinedValuesKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}).Type1()):          CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}).Type1()):      CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyCodec struct {
}

func (CaPoolSpecIssuancePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicy)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicy)(ptr)
	var objs []CaPoolSpecIssuancePolicy
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicy)(ptr) = CaPoolSpecIssuancePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicy)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicy)(ptr) = CaPoolSpecIssuancePolicy{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicy)(ptr) = CaPoolSpecIssuancePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicy)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicy)(ptr) = CaPoolSpecIssuancePolicy{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec struct {
}

func (CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr)
	var objs []CaPoolSpecIssuancePolicyAllowedIssuanceModes
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyAllowedIssuanceModes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedIssuanceModes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyAllowedIssuanceModesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = CaPoolSpecIssuancePolicyAllowedIssuanceModes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyAllowedIssuanceModes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedIssuanceModes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = CaPoolSpecIssuancePolicyAllowedIssuanceModes{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = CaPoolSpecIssuancePolicyAllowedIssuanceModes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyAllowedIssuanceModes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedIssuanceModes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedIssuanceModes)(ptr) = CaPoolSpecIssuancePolicyAllowedIssuanceModes{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyAllowedIssuanceModes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec struct {
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr)
	var objs []CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyAllowedKeyTypesEllipticCurve", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec struct {
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr)
	var objs []CaPoolSpecIssuancePolicyAllowedKeyTypesRsa
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyAllowedKeyTypesRsaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyAllowedKeyTypesRsa

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyAllowedKeyTypesRsa

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyAllowedKeyTypesRsa)(ptr) = CaPoolSpecIssuancePolicyAllowedKeyTypesRsa{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyAllowedKeyTypesRsa", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValues)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValues)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValues
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = CaPoolSpecIssuancePolicyBaselineValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = CaPoolSpecIssuancePolicyBaselineValues{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = CaPoolSpecIssuancePolicyBaselineValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValues)(ptr) = CaPoolSpecIssuancePolicyBaselineValues{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValuesAdditionalExtensionsObjectID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValuesCaOptions
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValuesCaOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesCaOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValuesCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValuesCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesCaOptions)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesCaOptions{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValuesCaOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsage
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValuesKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsage{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValuesKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec struct {
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr)
	var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage)(ptr) = CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyIdentityConstraintsCodec struct {
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr)
	var objs []CaPoolSpecIssuancePolicyIdentityConstraints
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyIdentityConstraints{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraints{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraints{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyIdentityConstraints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraints{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraints{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyIdentityConstraints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyIdentityConstraints)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraints{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyIdentityConstraints", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec struct {
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) == nil
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr)
	var objs []CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression
	if obj != nil {
		objs = []CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecIssuancePolicyIdentityConstraintsCelExpressionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}
			}
		} else {
			*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = obj
		} else {
			*(*CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression)(ptr) = CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression{}
		}
	default:
		iter.ReportError("decode CaPoolSpecIssuancePolicyIdentityConstraintsCelExpression", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolSpecPublishingOptionsCodec struct {
}

func (CaPoolSpecPublishingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolSpecPublishingOptions)(ptr) == nil
}

func (CaPoolSpecPublishingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolSpecPublishingOptions)(ptr)
	var objs []CaPoolSpecPublishingOptions
	if obj != nil {
		objs = []CaPoolSpecPublishingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecPublishingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolSpecPublishingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolSpecPublishingOptions)(ptr) = CaPoolSpecPublishingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolSpecPublishingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecPublishingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolSpecPublishingOptions)(ptr) = objs[0]
			} else {
				*(*CaPoolSpecPublishingOptions)(ptr) = CaPoolSpecPublishingOptions{}
			}
		} else {
			*(*CaPoolSpecPublishingOptions)(ptr) = CaPoolSpecPublishingOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolSpecPublishingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolSpecPublishingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolSpecPublishingOptions)(ptr) = obj
		} else {
			*(*CaPoolSpecPublishingOptions)(ptr) = CaPoolSpecPublishingOptions{}
		}
	default:
		iter.ReportError("decode CaPoolSpecPublishingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolIamBindingSpecConditionCodec struct {
}

func (CaPoolIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolIamBindingSpecCondition)(ptr) == nil
}

func (CaPoolIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolIamBindingSpecCondition)(ptr)
	var objs []CaPoolIamBindingSpecCondition
	if obj != nil {
		objs = []CaPoolIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolIamBindingSpecCondition)(ptr) = CaPoolIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*CaPoolIamBindingSpecCondition)(ptr) = CaPoolIamBindingSpecCondition{}
			}
		} else {
			*(*CaPoolIamBindingSpecCondition)(ptr) = CaPoolIamBindingSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolIamBindingSpecCondition)(ptr) = obj
		} else {
			*(*CaPoolIamBindingSpecCondition)(ptr) = CaPoolIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode CaPoolIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CaPoolIamMemberSpecConditionCodec struct {
}

func (CaPoolIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CaPoolIamMemberSpecCondition)(ptr) == nil
}

func (CaPoolIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CaPoolIamMemberSpecCondition)(ptr)
	var objs []CaPoolIamMemberSpecCondition
	if obj != nil {
		objs = []CaPoolIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CaPoolIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CaPoolIamMemberSpecCondition)(ptr) = CaPoolIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CaPoolIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CaPoolIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*CaPoolIamMemberSpecCondition)(ptr) = CaPoolIamMemberSpecCondition{}
			}
		} else {
			*(*CaPoolIamMemberSpecCondition)(ptr) = CaPoolIamMemberSpecCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CaPoolIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CaPoolIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CaPoolIamMemberSpecCondition)(ptr) = obj
		} else {
			*(*CaPoolIamMemberSpecCondition)(ptr) = CaPoolIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode CaPoolIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigCodec struct {
}

func (CertificateSpecConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfig)(ptr) == nil
}

func (CertificateSpecConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfig)(ptr)
	var objs []CertificateSpecConfig
	if obj != nil {
		objs = []CertificateSpecConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfig)(ptr) = CertificateSpecConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfig)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfig)(ptr) = CertificateSpecConfig{}
			}
		} else {
			*(*CertificateSpecConfig)(ptr) = CertificateSpecConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfig)(ptr) = obj
		} else {
			*(*CertificateSpecConfig)(ptr) = CertificateSpecConfig{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigPublicKeyCodec struct {
}

func (CertificateSpecConfigPublicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigPublicKey)(ptr) == nil
}

func (CertificateSpecConfigPublicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigPublicKey)(ptr)
	var objs []CertificateSpecConfigPublicKey
	if obj != nil {
		objs = []CertificateSpecConfigPublicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigPublicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigPublicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigPublicKey)(ptr) = CertificateSpecConfigPublicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigPublicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigPublicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigPublicKey)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigPublicKey)(ptr) = CertificateSpecConfigPublicKey{}
			}
		} else {
			*(*CertificateSpecConfigPublicKey)(ptr) = CertificateSpecConfigPublicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigPublicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigPublicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigPublicKey)(ptr) = obj
		} else {
			*(*CertificateSpecConfigPublicKey)(ptr) = CertificateSpecConfigPublicKey{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigPublicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigSubjectConfigCodec struct {
}

func (CertificateSpecConfigSubjectConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigSubjectConfig)(ptr) == nil
}

func (CertificateSpecConfigSubjectConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigSubjectConfig)(ptr)
	var objs []CertificateSpecConfigSubjectConfig
	if obj != nil {
		objs = []CertificateSpecConfigSubjectConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigSubjectConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigSubjectConfig)(ptr) = CertificateSpecConfigSubjectConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigSubjectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigSubjectConfig)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigSubjectConfig)(ptr) = CertificateSpecConfigSubjectConfig{}
			}
		} else {
			*(*CertificateSpecConfigSubjectConfig)(ptr) = CertificateSpecConfigSubjectConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigSubjectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigSubjectConfig)(ptr) = obj
		} else {
			*(*CertificateSpecConfigSubjectConfig)(ptr) = CertificateSpecConfigSubjectConfig{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigSubjectConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigSubjectConfigSubjectCodec struct {
}

func (CertificateSpecConfigSubjectConfigSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigSubjectConfigSubject)(ptr) == nil
}

func (CertificateSpecConfigSubjectConfigSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigSubjectConfigSubject)(ptr)
	var objs []CertificateSpecConfigSubjectConfigSubject
	if obj != nil {
		objs = []CertificateSpecConfigSubjectConfigSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigSubjectConfigSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = CertificateSpecConfigSubjectConfigSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigSubjectConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = CertificateSpecConfigSubjectConfigSubject{}
			}
		} else {
			*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = CertificateSpecConfigSubjectConfigSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigSubjectConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = obj
		} else {
			*(*CertificateSpecConfigSubjectConfigSubject)(ptr) = CertificateSpecConfigSubjectConfigSubject{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigSubjectConfigSubject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigSubjectConfigSubjectAltNameCodec struct {
}

func (CertificateSpecConfigSubjectConfigSubjectAltNameCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) == nil
}

func (CertificateSpecConfigSubjectConfigSubjectAltNameCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr)
	var objs []CertificateSpecConfigSubjectConfigSubjectAltName
	if obj != nil {
		objs = []CertificateSpecConfigSubjectConfigSubjectAltName{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubjectAltName{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigSubjectConfigSubjectAltNameCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateSpecConfigSubjectConfigSubjectAltName{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigSubjectConfigSubjectAltName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubjectAltName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateSpecConfigSubjectConfigSubjectAltName{}
			}
		} else {
			*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateSpecConfigSubjectConfigSubjectAltName{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigSubjectConfigSubjectAltName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigSubjectConfigSubjectAltName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = obj
		} else {
			*(*CertificateSpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateSpecConfigSubjectConfigSubjectAltName{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigSubjectConfigSubjectAltName", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigCodec struct {
}

func (CertificateSpecConfigX509ConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509Config)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509Config)(ptr)
	var objs []CertificateSpecConfigX509Config
	if obj != nil {
		objs = []CertificateSpecConfigX509Config{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509Config{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509Config)(ptr) = CertificateSpecConfigX509Config{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509Config

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509Config{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509Config)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509Config)(ptr) = CertificateSpecConfigX509Config{}
			}
		} else {
			*(*CertificateSpecConfigX509Config)(ptr) = CertificateSpecConfigX509Config{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509Config

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509Config{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509Config)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509Config)(ptr) = CertificateSpecConfigX509Config{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509Config", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec struct {
}

func (CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr)
	var objs []CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID
	if obj != nil {
		objs = []CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}
			}
		} else {
			*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509ConfigAdditionalExtensionsObjectID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigCaOptionsCodec struct {
}

func (CertificateSpecConfigX509ConfigCaOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509ConfigCaOptions)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigCaOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509ConfigCaOptions)(ptr)
	var objs []CertificateSpecConfigX509ConfigCaOptions
	if obj != nil {
		objs = []CertificateSpecConfigX509ConfigCaOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigCaOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigCaOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = CertificateSpecConfigX509ConfigCaOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509ConfigCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = CertificateSpecConfigX509ConfigCaOptions{}
			}
		} else {
			*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = CertificateSpecConfigX509ConfigCaOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509ConfigCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509ConfigCaOptions)(ptr) = CertificateSpecConfigX509ConfigCaOptions{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509ConfigCaOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigKeyUsageCodec struct {
}

func (CertificateSpecConfigX509ConfigKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509ConfigKeyUsage)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509ConfigKeyUsage)(ptr)
	var objs []CertificateSpecConfigX509ConfigKeyUsage
	if obj != nil {
		objs = []CertificateSpecConfigX509ConfigKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509ConfigKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsage{}
			}
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509ConfigKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509ConfigKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec struct {
}

func (CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr)
	var objs []CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage
	if obj != nil {
		objs = []CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}
			}
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509ConfigKeyUsageBaseKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec struct {
}

func (CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) == nil
}

func (CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr)
	var objs []CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage
	if obj != nil {
		objs = []CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
			}
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = obj
		} else {
			*(*CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateSpecConfigX509ConfigKeyUsageExtendedKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigCodec struct {
}

func (CertificateAuthoritySpecConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfig)(ptr) == nil
}

func (CertificateAuthoritySpecConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfig)(ptr)
	var objs []CertificateAuthoritySpecConfig
	if obj != nil {
		objs = []CertificateAuthoritySpecConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfig)(ptr) = CertificateAuthoritySpecConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfig)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfig)(ptr) = CertificateAuthoritySpecConfig{}
			}
		} else {
			*(*CertificateAuthoritySpecConfig)(ptr) = CertificateAuthoritySpecConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfig)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfig)(ptr) = CertificateAuthoritySpecConfig{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigSubjectConfigCodec struct {
}

func (CertificateAuthoritySpecConfigSubjectConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigSubjectConfig)(ptr) == nil
}

func (CertificateAuthoritySpecConfigSubjectConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigSubjectConfig)(ptr)
	var objs []CertificateAuthoritySpecConfigSubjectConfig
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigSubjectConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigSubjectConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = CertificateAuthoritySpecConfigSubjectConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigSubjectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = CertificateAuthoritySpecConfigSubjectConfig{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = CertificateAuthoritySpecConfigSubjectConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigSubjectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfig)(ptr) = CertificateAuthoritySpecConfigSubjectConfig{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigSubjectConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigSubjectConfigSubjectCodec struct {
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) == nil
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr)
	var objs []CertificateAuthoritySpecConfigSubjectConfigSubject
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigSubjectConfigSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigSubjectConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubject{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigSubjectConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfigSubject)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubject{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigSubjectConfigSubject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec struct {
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) == nil
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr)
	var objs []CertificateAuthoritySpecConfigSubjectConfigSubjectAltName
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigSubjectConfigSubjectAltNameCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigSubjectConfigSubjectAltName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigSubjectConfigSubjectAltName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigSubjectConfigSubjectAltName)(ptr) = CertificateAuthoritySpecConfigSubjectConfigSubjectAltName{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigSubjectConfigSubjectAltName", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509Config)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509Config)(ptr)
	var objs []CertificateAuthoritySpecConfigX509Config
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509Config{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509Config{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509Config)(ptr) = CertificateAuthoritySpecConfigX509Config{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509Config

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509Config{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509Config)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509Config)(ptr) = CertificateAuthoritySpecConfigX509Config{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509Config)(ptr) = CertificateAuthoritySpecConfigX509Config{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509Config

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509Config{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509Config)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509Config)(ptr) = CertificateAuthoritySpecConfigX509Config{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509Config", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr)
	var objs []CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID)(ptr) = CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509ConfigAdditionalExtensionsObjectID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr)
	var objs []CertificateAuthoritySpecConfigX509ConfigCaOptions
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509ConfigCaOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigCaOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigCaOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = CertificateAuthoritySpecConfigX509ConfigCaOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509ConfigCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = CertificateAuthoritySpecConfigX509ConfigCaOptions{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = CertificateAuthoritySpecConfigX509ConfigCaOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509ConfigCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigCaOptions)(ptr) = CertificateAuthoritySpecConfigX509ConfigCaOptions{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509ConfigCaOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr)
	var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsage
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509ConfigKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsage{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509ConfigKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509ConfigKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr)
	var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509ConfigKeyUsageBaseKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec struct {
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) == nil
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr)
	var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage
	if obj != nil {
		objs = []CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
			}
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage)(ptr) = CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecConfigX509ConfigKeyUsageExtendedKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateAuthoritySpecKeySpecCodec struct {
}

func (CertificateAuthoritySpecKeySpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateAuthoritySpecKeySpec)(ptr) == nil
}

func (CertificateAuthoritySpecKeySpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateAuthoritySpecKeySpec)(ptr)
	var objs []CertificateAuthoritySpecKeySpec
	if obj != nil {
		objs = []CertificateAuthoritySpecKeySpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecKeySpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateAuthoritySpecKeySpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateAuthoritySpecKeySpec)(ptr) = CertificateAuthoritySpecKeySpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateAuthoritySpecKeySpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecKeySpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateAuthoritySpecKeySpec)(ptr) = objs[0]
			} else {
				*(*CertificateAuthoritySpecKeySpec)(ptr) = CertificateAuthoritySpecKeySpec{}
			}
		} else {
			*(*CertificateAuthoritySpecKeySpec)(ptr) = CertificateAuthoritySpecKeySpec{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateAuthoritySpecKeySpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateAuthoritySpecKeySpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateAuthoritySpecKeySpec)(ptr) = obj
		} else {
			*(*CertificateAuthoritySpecKeySpec)(ptr) = CertificateAuthoritySpecKeySpec{}
		}
	default:
		iter.ReportError("decode CertificateAuthoritySpecKeySpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecIdentityConstraintsCodec struct {
}

func (CertificateTemplateSpecIdentityConstraintsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecIdentityConstraints)(ptr) == nil
}

func (CertificateTemplateSpecIdentityConstraintsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecIdentityConstraints)(ptr)
	var objs []CertificateTemplateSpecIdentityConstraints
	if obj != nil {
		objs = []CertificateTemplateSpecIdentityConstraints{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraints{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecIdentityConstraintsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecIdentityConstraints)(ptr) = CertificateTemplateSpecIdentityConstraints{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecIdentityConstraints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecIdentityConstraints)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecIdentityConstraints)(ptr) = CertificateTemplateSpecIdentityConstraints{}
			}
		} else {
			*(*CertificateTemplateSpecIdentityConstraints)(ptr) = CertificateTemplateSpecIdentityConstraints{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecIdentityConstraints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecIdentityConstraints)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecIdentityConstraints)(ptr) = CertificateTemplateSpecIdentityConstraints{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecIdentityConstraints", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecIdentityConstraintsCelExpressionCodec struct {
}

func (CertificateTemplateSpecIdentityConstraintsCelExpressionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) == nil
}

func (CertificateTemplateSpecIdentityConstraintsCelExpressionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr)
	var objs []CertificateTemplateSpecIdentityConstraintsCelExpression
	if obj != nil {
		objs = []CertificateTemplateSpecIdentityConstraintsCelExpression{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraintsCelExpression{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecIdentityConstraintsCelExpressionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = CertificateTemplateSpecIdentityConstraintsCelExpression{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecIdentityConstraintsCelExpression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraintsCelExpression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = CertificateTemplateSpecIdentityConstraintsCelExpression{}
			}
		} else {
			*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = CertificateTemplateSpecIdentityConstraintsCelExpression{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecIdentityConstraintsCelExpression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecIdentityConstraintsCelExpression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecIdentityConstraintsCelExpression)(ptr) = CertificateTemplateSpecIdentityConstraintsCelExpression{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecIdentityConstraintsCelExpression", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPassthroughExtensionsCodec struct {
}

func (CertificateTemplateSpecPassthroughExtensionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPassthroughExtensions)(ptr) == nil
}

func (CertificateTemplateSpecPassthroughExtensionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPassthroughExtensions)(ptr)
	var objs []CertificateTemplateSpecPassthroughExtensions
	if obj != nil {
		objs = []CertificateTemplateSpecPassthroughExtensions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPassthroughExtensions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPassthroughExtensionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = CertificateTemplateSpecPassthroughExtensions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPassthroughExtensions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPassthroughExtensions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = CertificateTemplateSpecPassthroughExtensions{}
			}
		} else {
			*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = CertificateTemplateSpecPassthroughExtensions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPassthroughExtensions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPassthroughExtensions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPassthroughExtensions)(ptr) = CertificateTemplateSpecPassthroughExtensions{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPassthroughExtensions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValues)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValues)(ptr)
	var objs []CertificateTemplateSpecPredefinedValues
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValues)(ptr) = CertificateTemplateSpecPredefinedValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValues)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValues)(ptr) = CertificateTemplateSpecPredefinedValues{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValues)(ptr) = CertificateTemplateSpecPredefinedValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValues)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValues)(ptr) = CertificateTemplateSpecPredefinedValues{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr)
	var objs []CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID)(ptr) = CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValuesAdditionalExtensionsObjectID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesCaOptionsCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesCaOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesCaOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr)
	var objs []CertificateTemplateSpecPredefinedValuesCaOptions
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValuesCaOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesCaOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesCaOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = CertificateTemplateSpecPredefinedValuesCaOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValuesCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = CertificateTemplateSpecPredefinedValuesCaOptions{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = CertificateTemplateSpecPredefinedValuesCaOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValuesCaOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesCaOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValuesCaOptions)(ptr) = CertificateTemplateSpecPredefinedValuesCaOptions{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValuesCaOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesKeyUsageCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr)
	var objs []CertificateTemplateSpecPredefinedValuesKeyUsage
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValuesKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValuesKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsage{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValuesKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValuesKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr)
	var objs []CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValuesKeyUsageBaseKeyUsage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec struct {
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) == nil
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr)
	var objs []CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage
	if obj != nil {
		objs = []CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = objs[0]
			} else {
				*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}
			}
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = obj
		} else {
			*(*CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage)(ptr) = CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage{}
		}
	default:
		iter.ReportError("decode CertificateTemplateSpecPredefinedValuesKeyUsageExtendedKeyUsage", "unexpected JSON type")
	}
}
