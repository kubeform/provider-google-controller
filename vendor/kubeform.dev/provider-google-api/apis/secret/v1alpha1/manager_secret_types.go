/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ManagerSecret struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagerSecretSpec   `json:"spec,omitempty"`
	Status            ManagerSecretStatus `json:"status,omitempty"`
}

type ManagerSecretSpecReplicationUserManagedReplicasCustomerManagedEncryption struct {
	// Describes the Cloud KMS encryption key that will be used to protect destination secret.
	KmsKeyName *string `json:"kmsKeyName" tf:"kms_key_name"`
}

type ManagerSecretSpecReplicationUserManagedReplicas struct {
	// Customer Managed Encryption for the secret.
	// +optional
	CustomerManagedEncryption *ManagerSecretSpecReplicationUserManagedReplicasCustomerManagedEncryption `json:"customerManagedEncryption,omitempty" tf:"customer_managed_encryption"`
	// The canonical IDs of the location to replicate data. For example: "us-east1".
	Location *string `json:"location" tf:"location"`
}

type ManagerSecretSpecReplicationUserManaged struct {
	// The list of Replicas for this Secret. Cannot be empty.
	// +kubebuilder:validation:MinItems=1
	Replicas []ManagerSecretSpecReplicationUserManagedReplicas `json:"replicas" tf:"replicas"`
}

type ManagerSecretSpecReplication struct {
	// The Secret will automatically be replicated without any restrictions.
	// +optional
	Automatic *bool `json:"automatic,omitempty" tf:"automatic"`
	// The Secret will automatically be replicated without any restrictions.
	// +optional
	UserManaged *ManagerSecretSpecReplicationUserManaged `json:"userManaged,omitempty" tf:"user_managed"`
}

type ManagerSecretSpecRotation struct {
	// Timestamp in UTC at which the Secret is scheduled to rotate.
	// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
	// +optional
	NextRotationTime *string `json:"nextRotationTime,omitempty" tf:"next_rotation_time"`
	// The Duration between rotation notifications. Must be in seconds and at least 3600s (1h) and at most 3153600000s (100 years).
	// If rotationPeriod is set, 'next_rotation_time' must be set. 'next_rotation_time' will be advanced by this period when the service automatically sends rotation notifications.
	// +optional
	RotationPeriod *string `json:"rotationPeriod,omitempty" tf:"rotation_period"`
}

type ManagerSecretSpecTopics struct {
	// The resource name of the Pub/Sub topic that will be published to, in the following format: projects/*/topics/*.
	// For publication to succeed, the Secret Manager Service Agent service account must have pubsub.publisher permissions on the topic.
	Name *string `json:"name" tf:"name"`
}

type ManagerSecretSpec struct {
	State *ManagerSecretSpecResource `json:"state,omitempty" tf:"-"`

	Resource ManagerSecretSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ManagerSecretSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The time at which the Secret was created.
	// +optional
	CreateTime *string `json:"createTime,omitempty" tf:"create_time"`
	// Timestamp in UTC when the Secret is scheduled to expire. This is always provided on output, regardless of what was sent on input.
	// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
	// +optional
	ExpireTime *string `json:"expireTime,omitempty" tf:"expire_time"`
	// The labels assigned to this Secret.
	//
	// Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes,
	// and must conform to the following PCRE regular expression: [\\p{Ll}\\p{Lo}][\\p{Ll}\\p{Lo}\\p{N}_-]{0,62}
	//
	// Label values must be between 0 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes,
	// and must conform to the following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
	//
	// No more than 64 labels can be assigned to a given resource.
	//
	// An object containing a list of "key": value pairs. Example:
	// { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
	// The resource name of the Secret. Format:
	// 'projects/{{project}}/secrets/{{secret_id}}'
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
	// The replication policy of the secret data attached to the Secret. It cannot be changed
	// after the Secret has been created.
	Replication *ManagerSecretSpecReplication `json:"replication" tf:"replication"`
	// The rotation time and period for a Secret. At 'next_rotation_time', Secret Manager will send a Pub/Sub notification to the topics configured on the Secret. 'topics' must be set to configure rotation.
	// +optional
	Rotation *ManagerSecretSpecRotation `json:"rotation,omitempty" tf:"rotation"`
	// This must be unique within the project.
	SecretID *string `json:"secretID" tf:"secret_id"`
	// A list of up to 10 Pub/Sub topics to which messages are published when control plane operations are called on the secret or its versions.
	// +optional
	Topics []ManagerSecretSpecTopics `json:"topics,omitempty" tf:"topics"`
	// The TTL for the Secret.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +optional
	Ttl *string `json:"ttl,omitempty" tf:"ttl"`
}

type ManagerSecretStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ManagerSecretList is a list of ManagerSecrets
type ManagerSecretList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ManagerSecret CRD objects
	Items []ManagerSecret `json:"items,omitempty"`
}
